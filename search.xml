<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[Android]Jetpack Compose 实现Banner轮播图</title>
      <link href="/2023/11/20/%5BAndroid%5DJetpack%20Compose%20%E5%AE%9E%E7%8E%B0Banner%E8%BD%AE%E6%92%AD%E5%9B%BE/"/>
      <url>/2023/11/20/%5BAndroid%5DJetpack%20Compose%20%E5%AE%9E%E7%8E%B0Banner%E8%BD%AE%E6%92%AD%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;Jetpack Compose 是推荐用于构建原生 Android 界面的新工具包。它可简化并加快 Android 上的界面开发，使用更少的代码、强大的工具和直观的 Kotlin API，快速打造生动而精彩的应用。</p><p>&emsp;&emsp;本次就使用 Jetpack Compose里面的分页器（pager）来实现一个常用控件——轮播图（Banner）。这里需要对Android Compose有一定的了解，可以先去学习一下Compose的基本知识，这里放上官方直达：<a href="https://developer.android.google.cn/jetpack/compose?hl=zh-cn">直达官方Compose</a> 。</p><p>&emsp;&emsp;同时这里也放上分页器的官方文档，可以了解更多高级功能，直达：<a href="https://developer.android.google.cn/jetpack/compose/layouts/pager?hl=zh-cn#custom-page">官方分页器文档</a>。</p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>&emsp;&emsp;首先需要分析一下实现轮播图的功能。</p><p>&emsp;&emsp;轮播图需要一直循环滑动播放，所以首先就是需要一个具有单页水平滑动效果的控件。在2023年3月底，Google 正式发布Jetpack Compose 的 1.4 版本，在这次的更新中，新增了 pager 等控件，它实现了View中ViewPager类似的功能。因此，水平分页器—— HorizontalPager 可以完美起这个重任。</p><p>&emsp;&emsp;可以分析一下HorizontalPager的源码</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Composable</span><span class="token annotation builtin">@ExperimentalFoundationApi</span><span class="token keyword">fun</span> <span class="token function">HorizontalPager</span><span class="token punctuation">(</span>    state<span class="token operator">:</span> PagerState<span class="token punctuation">,</span>    modifier<span class="token operator">:</span> Modifier <span class="token operator">=</span> Modifier<span class="token punctuation">,</span>    contentPadding<span class="token operator">:</span> PaddingValues <span class="token operator">=</span> <span class="token function">PaddingValues</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span><span class="token punctuation">,</span>    pageSize<span class="token operator">:</span> PageSize <span class="token operator">=</span> PageSize<span class="token punctuation">.</span>Fill<span class="token punctuation">,</span>    beyondBoundsPageCount<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    pageSpacing<span class="token operator">:</span> Dp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">.</span>dp<span class="token punctuation">,</span>    verticalAlignment<span class="token operator">:</span> Alignment<span class="token punctuation">.</span>Vertical <span class="token operator">=</span> Alignment<span class="token punctuation">.</span>CenterVertically<span class="token punctuation">,</span>    flingBehavior<span class="token operator">:</span> SnapFlingBehavior <span class="token operator">=</span> PagerDefaults<span class="token punctuation">.</span><span class="token function">flingBehavior</span><span class="token punctuation">(</span>state <span class="token operator">=</span> state<span class="token punctuation">)</span><span class="token punctuation">,</span>    userScrollEnabled<span class="token operator">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    reverseLayout<span class="token operator">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    key<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>index<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">-></span> Any<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span>    pageNestedScrollConnection<span class="token operator">:</span> NestedScrollConnection <span class="token operator">=</span>     PagerDefaults<span class="token punctuation">.</span><span class="token function">pageNestedScrollConnection</span><span class="token punctuation">(</span>        Orientation<span class="token punctuation">.</span>Horizontal    <span class="token punctuation">)</span><span class="token punctuation">,</span>    pageContent<span class="token operator">:</span> <span class="token annotation builtin">@Composable</span> PagerScope<span class="token punctuation">.</span><span class="token punctuation">(</span>page<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;其中最重要的当然是PagerState，顾名思义，这个就是用来管理HorizontalPager内pager状态的。这里是HorizontalPager的简单使用。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"> <span class="token comment">// 显示 10 个项目</span> <span class="token function">HorizontalPager</span><span class="token punctuation">(</span>pageCount <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> page <span class="token operator">-></span>     <span class="token comment">// 每一页的内容，比如显示个文本</span>     <span class="token function">Text</span><span class="token punctuation">(</span>         text <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Page: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">page</span></span><span class="token string">"</span></span><span class="token punctuation">,</span>         modifier <span class="token operator">=</span> Modifier<span class="token punctuation">.</span><span class="token function">fillMaxWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;然后就是在人没有对其进行滑动的时候，需要轮播图进行自动循环，并具有延迟展示图片内容。PagerState提供了方法可以获得当前Pager是否处于拖动状态。所以可以先使用这个方法获得当前状态，然后进行判断。延迟则可以使用delay函数来实现。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> isDragged <span class="token keyword">by</span> pagerState<span class="token punctuation">.</span>interactionSource<span class="token punctuation">.</span><span class="token function">collectIsDraggedAsState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&emsp;&emsp;最后还需要一个指示器，也可以使用 Box 或者 Canvas 简单实现，方法众多，可以尽情发挥。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>&emsp;&emsp;通过上面的分析，可以来实现轮播图Banner了，现在将实现分为三步。</p><h2 id="水平分页器"><a href="#水平分页器" class="headerlink" title="水平分页器"></a>水平分页器</h2><p>&emsp;&emsp;首先需要定义好Pager的数量——pagerCount。这里我定义了一个List用来存储图片的URL，之后也是使用了coil库来加载图片。因此，这里的 pagerCount 就等于 images.size。</p><p>&emsp;&emsp;接着就是定义 HorizontalPager 的 pagerState，直接使用 rememberPagerState，然后将 pagerCount 传入。</p><p>&emsp;&emsp;然后就可以使用HorizontalPager了，这里也设置了一下pageSpacing 来分隔此分页器中页面的空间量。同时写了个 BannerCard 来修饰一下图片，传入图片URL，然后使用 coil 的 AsyncImage 来加载图片。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token annotation builtin">@OptIn</span><span class="token punctuation">(</span>ExperimentalFoundationApi<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation builtin">@Composable</span><span class="token keyword">fun</span> <span class="token function">Banner</span><span class="token punctuation">(</span>    images<span class="token operator">:</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span>    autoScrollDuration<span class="token operator">:</span> Long <span class="token operator">=</span> <span class="token number">1500L</span>   <span class="token comment">//延迟的时间，可以自行设置，后面要用到。</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> pagerCount <span class="token operator">=</span> images<span class="token punctuation">.</span>size    <span class="token keyword">val</span> pagerState <span class="token operator">=</span> rememberPagerState<span class="token punctuation">&#123;</span>        pagerCount    <span class="token punctuation">&#125;</span>    Box <span class="token punctuation">&#123;</span>        <span class="token function">HorizontalPager</span><span class="token punctuation">(</span>            state <span class="token operator">=</span> pagerState<span class="token punctuation">,</span>            contentPadding <span class="token operator">=</span> <span class="token function">PaddingValues</span><span class="token punctuation">(</span>horizontal <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span><span class="token punctuation">,</span>            pageSpacing <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">.</span>dp        <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>index <span class="token operator">-></span>            <span class="token function">BannerCard</span><span class="token punctuation">(</span>                imageURL <span class="token operator">=</span> images<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span>                modifier <span class="token operator">=</span> Modifier                    <span class="token punctuation">.</span><span class="token function">padding</span><span class="token punctuation">(</span>top <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span>            <span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation builtin">@Composable</span><span class="token keyword">fun</span> <span class="token function">BannerCard</span><span class="token punctuation">(</span>    imageURL <span class="token operator">:</span> String<span class="token punctuation">,</span>    modifier <span class="token operator">:</span> Modifier<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">Card</span> <span class="token punctuation">(</span>modifier <span class="token operator">=</span> modifier<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">AsyncImage</span><span class="token punctuation">(</span>model <span class="token operator">=</span> imageURL<span class="token punctuation">,</span> contentDescription <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;实现效果如下</p><p><img src="/$%7BuseImgs%7D/gif_1.gif" alt=""></p><h2 id="自动循环与延迟"><a href="#自动循环与延迟" class="headerlink" title="自动循环与延迟"></a>自动循环与延迟</h2><p>&emsp;&emsp;首先先定义一个布尔类型的 isDragged 来获取是否处于拖动状态，然后对其进行判断，当没有人为拖动时，使用kotlin中的with 函数，在里面设立一个局部变量来储存当前页数的值，然后将其作为 LaunchedEffect （协程是Android kotlin开发中一个重要知识，在Compose中采用附带效应 effect 来实现协程开发）的参数，在协程使用 pagerState 的函数 animateScrollToPage 来实现自动滑动，nextPage 通过当前页数 + 1然后再对总页数取模来实现循环。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> isDragged <span class="token keyword">by</span> pagerState<span class="token punctuation">.</span>interactionSource<span class="token punctuation">.</span><span class="token function">collectIsDraggedAsState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>isDragged<span class="token punctuation">.</span><span class="token function">not</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">with</span><span class="token punctuation">(</span>pagerState<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">var</span> currentPageKey <span class="token keyword">by</span> remember <span class="token punctuation">&#123;</span> <span class="token function">mutableIntStateOf</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>            <span class="token function">LaunchedEffect</span><span class="token punctuation">(</span>key1 <span class="token operator">=</span> currentPageKey<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                launch <span class="token punctuation">&#123;</span>                    <span class="token function">delay</span><span class="token punctuation">(</span>timeMillis <span class="token operator">=</span> autoScrollDuration<span class="token punctuation">)</span>                    <span class="token keyword">val</span> nextPage <span class="token operator">=</span> <span class="token punctuation">(</span>currentPage <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mod</span><span class="token punctuation">(</span>pageCount<span class="token punctuation">)</span>                    <span class="token function">animateScrollToPage</span><span class="token punctuation">(</span>page <span class="token operator">=</span> nextPage<span class="token punctuation">)</span>                    currentPageKey <span class="token operator">=</span> nextPage                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;将其加入后再次启动（虚拟机！启动！！！）如下，发现已经可以自己循环播放了。</p><p><img src="/$%7BuseImgs%7D/gif_2.gif" alt=""></p><h2 id="添加指示器"><a href="#添加指示器" class="headerlink" title="添加指示器"></a>添加指示器</h2><p>&emsp;&emsp;添加指示器，本蒟蒻采用的是 Canvas 来实现。首先在一行中使用 repeat 函数进行重复，有多少张图就 repeat 多少次，即repeat（pageCount）,然后定义颜色，与当前页数相同的指示点颜色与其他点颜色进行区别，既然要画点，所以使用 Canvas 中的 drawCircle 来进行绘画，可以自行定义大小。</p><p>&emsp;&emsp;因为要使用pagerState来获得当前页数，所以指示器需要传入pagerState，和pagerCount。同时需要通过 modifier 修饰符将指示器放在父 Box 容器的底部，这样指示器就可以显示在图片的上方，并处于底部。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token annotation builtin">@OptIn</span><span class="token punctuation">(</span>ExperimentalFoundationApi<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation builtin">@Composable</span><span class="token keyword">fun</span> <span class="token function">DotIndicators</span><span class="token punctuation">(</span>    pageCount <span class="token operator">:</span> Int<span class="token punctuation">,</span>    pagerState <span class="token operator">:</span> PagerState<span class="token punctuation">,</span>    modifier<span class="token operator">:</span> Modifier<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">Row</span> <span class="token punctuation">(</span>        modifier <span class="token operator">=</span> modifier<span class="token punctuation">.</span><span class="token function">padding</span><span class="token punctuation">(</span>bottom <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span><span class="token punctuation">,</span>        horizontalArrangement <span class="token operator">=</span> Arrangement<span class="token punctuation">.</span>Center<span class="token punctuation">,</span>        verticalAlignment <span class="token operator">=</span> Alignment<span class="token punctuation">.</span>Bottom    <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">repeat</span><span class="token punctuation">(</span>pageCount<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>iteration <span class="token operator">-></span>            <span class="token keyword">val</span> color <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pagerState<span class="token punctuation">.</span>currentPage <span class="token operator">==</span> iteration<span class="token punctuation">)</span> MaterialTheme<span class="token punctuation">.</span>colorScheme<span class="token punctuation">.</span>surface                           <span class="token keyword">else</span> MaterialTheme<span class="token punctuation">.</span>colorScheme<span class="token punctuation">.</span>onSurface            <span class="token function">Canvas</span><span class="token punctuation">(</span>                modifier <span class="token operator">=</span> Modifier                <span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">padding</span><span class="token punctuation">(</span>horizontal <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span><span class="token punctuation">,</span> onDraw <span class="token operator">=</span> <span class="token punctuation">&#123;</span>                <span class="token function">drawCircle</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;最后再次启动！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;如此如此，这般这般，就实现了轮播图的效果，如果任觉得不满于此，也可以跟随自己的想法去将其变得更加 niu pi。同时也可以多多探索。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Compose </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[深入理解计算机系统]CSAPP DataLab 学习记录</title>
      <link href="/2023/10/11/%5B%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%5DCSAPP%20DataLab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/10/11/%5B%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%5DCSAPP%20DataLab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p>&emsp;&emsp;最近在看完《深入理解计算机系统》前两章之后，也将其第一个Lab——DataLab完成了，于是来对此做一个记录。DataLab主要是对整型和浮点型的实验，其中对条件语句、算数运算还有逻辑运算进行了不同的限制。</p><h1 id="实验环境的搭建："><a href="#实验环境的搭建：" class="headerlink" title="实验环境的搭建："></a>实验环境的搭建：</h1><p>&emsp;&emsp;首先由于其实验环境是unix，我使用的是VMware Workstation + Ubuntu来搭建实验环境。VMware虚拟机和Ubuntu的安装可以看这篇博客<a href="https://blog.csdn.net/qq_41782425/article/details/85119258">VMware Ubuntu安装详细过程（详细图解）_vmware安装ubuntu-CSDN博客</a>，具体搭建过程可看这篇博客：<a href="https://blog.csdn.net/qq_39876147/article/details/124481740">【CSAPP】Lab0 - 环境配置_csapp 3e操作环境搭建_Luqwera的博客-CSDN博客</a>。</p><p>&emsp;&emsp;如果不想安装虚拟机，也可以使用Docker里的Linux容器来搭建，具体的操作过程可看这篇博客<a href="https://blog.csdn.net/qq_39029579/article/details/112169980">超详解 CS:APP:Lab1-DataLab_optional cmd line args-CSDN博客</a>。</p><p>&emsp;&emsp;完成环境的搭建后便可以开始做DataLab了。</p><h1 id="问题描述及解析："><a href="#问题描述及解析：" class="headerlink" title="问题描述及解析："></a>问题描述及解析：</h1><h2 id="1-bitXor"><a href="#1-bitXor" class="headerlink" title="1.bitXor"></a>1.bitXor</h2><p>&emsp;&emsp;题目的意思就是只使用 ~（取反符号） 和 &amp; （与运算符）来实现 ^ (异或)。</p><p>&emsp;&emsp;看到这个，首先想到了数字逻辑里的一个公式：</p><p><img src="/imgs/$%7BuseImgs%7D/img_1.png" alt=""></p><p>&emsp;&emsp;就是 “同或的非” = “异或”，但是里面有“或”运算符，所以要再使用一下德摩根定律：</p><p>​                                                                            <img src="/imgs/$%7BuseImgs%7D/img_2.png" alt=""></p><p>&emsp;&emsp;就可以解决这道题了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~(x &amp; y) &amp; ~(~x &amp; ~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-tmin"><a href="#2-tmin" class="headerlink" title="2.tmin"></a>2.tmin</h2><p>&emsp;&emsp;题目的意思就是返回对32位 int 最小的二补数（就是补码）。下面是 n 比特的二补数系统中几个特别的数字：</p><div class="table-container"><table><thead><tr><th style="text-align:center">二补数</th><th style="text-align:center">实际数字</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">0111 1111 …. 1111</td><td style="text-align:center">$2^{n-1} -1$</td><td style="text-align:center">最大正数</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">0000 0000 …. 0001</td><td style="text-align:center">1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">0000 0000 …. 0000</td><td style="text-align:center">0</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">1111 1111 …. 1111</td><td style="text-align:center">-1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">1000 0000 …. 0000</td><td style="text-align:center">$-2^{n-1}$</td><td style="text-align:center">最小负数</td></tr></tbody></table></div><p>&emsp;&emsp;所以在32位的环境下，补码的最小值就是：Tmin = $-2^{32-1}$$=-2^{31}$。用十六进制表示就是0x80000000，及将 1 向左移 31位。这样就可以解决了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-isTmax"><a href="#3-isTmax" class="headerlink" title="3.isTmax"></a>3.isTmax</h2><p>&emsp;&emsp;这道题目需要你对输入的 x 进行判断是否为最大的补码，如果是就返回 1 ，不是则返回 0 。</p><p>&emsp;&emsp;由上一题可以知道，在32位的环境中最大的补码为 $2^{31}-1$ 及 0111 1111 …. 1111，所以我们可以从这个最大数入手。</p><p>&emsp;&emsp;首先可以发现 Tmax = 0111 1111 …. 1111 在加上一个 1 后会直接溢出变成 1000 0000 …. 0000，然后再对其取反后，就又变回了原来的 Tmax，故可以得到~(Tmax+1)= Tmax，因此，我们现在只需要判断~(x+1)与 x 是否相等就可以得出结论。但是题目限制无法使用等号，所以就可以利用异或运算的一个特性，即 x⊕x=0 ，就是两个相同的数进行异或后结果为 0 ，这里需要相同情况下返回 1，故要使用 ! 符号。所以最后组合在一起就是:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return !(~(x+1)^x);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是当你保存检测后发现没有通过。</p><p><img src="/imgs/$%7BuseImgs%7D/img_3.png" alt=""></p><p>&emsp;&emsp;仔细看了错误后会发现当 x = -1 时，返回的是 1 ，但应该是 0。这是因为在补码中 -1 = 1111 1111 …. 1111，-1+1 = 1 0000 0000 …. 0000 ，由于超过了32位的比特位，所以会被截断，高位进位无效，此时等于 0000 0000 …. 0000，即为0，而且正好每一位都与 -1的每一位互补。故需要我们来对 -1 进行特判。可以在 x+1 后对其进行 !! 操作来区别最大值和 -1 。</p><p>&emsp;&emsp;故最终解决方法如下。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !(~(x+<span class="number">1</span>)^x)&amp;!!(x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-allOddBits"><a href="#4-allOddBits" class="headerlink" title="4.allOddBits"></a>4.allOddBits</h2><p>&emsp;&emsp;该题的意思和上题差不多，就是判断 x 补码的奇数位是否全为 1，如果是就返回1，不是则返回0。并且告知了你32位是从第0位到第31位，所以不要判断错了。</p><p>&emsp;&emsp;读懂题意，就能想到用奇数位上全是1，偶数位上全为0的数，即0xAAAAAAAA与 x 进行与运算（&amp;），再看其结果是否任然等于0xAAAAAAAA，若相等，则 x 符合条件，返回1，不等则返回0。同样这一题与上一题一样，无法使用等号，所以继续使用异或来判断。但是需要注意本实验有一个要求</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">Integer constants 0 through 255 (0xFF), inclusive. You are</span><br><span class="line">      not allowed to use big constants such as 0xffffffff.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;故无法直接定义 0xAAAAAAAA这么大的数，所以需要先得到0xAAAAAAAA。可以考虑用0xAA，通过移位和运算获得。之后就迎刃而解了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> temp = <span class="number">0xAA</span>;</span><br><span class="line">  <span class="type">int</span> a = temp + (temp&lt;&lt;<span class="number">8</span>);</span><br><span class="line">  <span class="type">int</span> b = a + (a&lt;&lt;<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">return</span> !((x&amp;b)^b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-negate"><a href="#5-negate" class="headerlink" title="5.negate"></a>5.negate</h2><p>&emsp;&emsp;这一题就是求 x 的相反数，一个很基础的结论就是~x + x = -1，调整一下就是 -x = ~x+1（牢记），补码的常见操作。</p><p>于是这题就解决了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-isAsciiDigit"><a href="#6-isAsciiDigit" class="headerlink" title="6.isAsciiDigit"></a>6.isAsciiDigit</h2><p>&emsp;&emsp;该题就是来判断 x 是否在 0x30 到 0x39 之间，如果是则返回 1。</p><p>&emsp;&emsp;思路就是先通过右移来判断除了后4位外，其余的位是否与0x3相同，将其作为第一个条件，然后来判断后四位是否在0到9之间。</p><p>&emsp;&emsp;第一个条件可以通过将 x 右移4位后与0x3进行异或来判断是否相同，第二条件就将 x 和0xF进行与运算这样就可以获得后四位所表示的数了，在将其减去10，即0xA，最后只用判断减去10后的结果的符号。由于无法使用减法，所以这里使用上一题的结论，加上-10就行，（-10 = ~10+1）。</p><p>&emsp;&emsp;最后可以通过右移31位获得结果的符号，若为负，则为-1，若为正，则为0，又因为任何一个数与-1进行与运算都会等于自己，所以第一个条件与第二个条件均成立时才会返回 1。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = !((x&gt;&gt;<span class="number">4</span>)^<span class="number">0x3</span>);</span><br><span class="line">  <span class="type">int</span> b = ((x &amp; <span class="number">0xf</span>) + ~<span class="number">0xA</span>+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> a &amp; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-conditional"><a href="#7-conditional" class="headerlink" title="7.conditional"></a>7.conditional</h2><p>&emsp;&emsp;这一题就是使用允许的运算操作符：!  ~  &amp;  ^  |  +  &lt;&lt;  &gt;&gt;，来实现三目运算符，即当 x 为真时（x ≠ 0）返回 y ，为假时（x = 0），返回 z 。</p><p>&emsp;&emsp;首先可以先判断 x 为真为假，对 x 使用两次 ! 运算，若 x 为真，则此时为 1，反之，此时为 0。接着可以想到题目不是返回 y 就是返回 z ，所以可以想到使用或运算（|），现在需要我们在 x 为真时，将包含 z 的那一部分变为0，包含 y 的那一部分变为 y ，反之同理。然后可以想到任何一个数与 0 进行与运算都等于 0  ，任何一个数与 -1 进行与运算都等于自己本身。并且 ~0 = -1，~(-1) = 0，对于0 和 -1 都是 x 为假为真时进行取反操作可以得到的，故可以列出下表</p><div class="table-container"><table><thead><tr><th style="text-align:center">x</th><th style="text-align:center">a=!!x</th><th style="text-align:center">b=~a+1</th><th style="text-align:center">b&amp;y</th><th style="text-align:center">~b&amp;z</th><th style="text-align:center">（b&amp;y)$\vert$(~b&amp;z)</th></tr></thead><tbody><tr><td style="text-align:center">真</td><td style="text-align:center">1</td><td style="text-align:center">-1</td><td style="text-align:center">y</td><td style="text-align:center">0</td><td style="text-align:center">y</td></tr><tr><td style="text-align:center">假</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">z</td><td style="text-align:center">z</td></tr></tbody></table></div><p>&emsp;&emsp;可以发现完全符合题目所需，故解决方法如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = !!x;</span><br><span class="line">  <span class="type">int</span> b = ~a+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (b &amp; y)|(~b &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-isLessOrEqual"><a href="#8-isLessOrEqual" class="headerlink" title="8.isLessOrEqual"></a>8.isLessOrEqual</h2><p>&emsp;&emsp;通过题目的描述，需要我们来判断 x 与 y 的大小，如果 x &lt;= y 时返回1，否则返回0。</p><p>&emsp;&emsp;首先可以很快想到如果 x 是个负数， y 是个正数，那么 x 一定小于 y，则一定返回1，相反，当  x 为正，y为负，则一定返回0。所以可以先判断符号，通过右移31来获取符号位，但由于负数一般采用的是算术右移，所以最后都需要与1进行与运算，得到符号位。</p><p>&emsp;&emsp;接着使用异或来判断是否符号相同，若相同，则需要用 x 减去 y，即加上-y ，再来判断相减之后的符号位，但同时要注意到当x = y时，相减之后符号位为 0 ，与 x &lt; y时相减后情况不同，所以在此用了另一种方法，x &lt;= y等同于 x &lt; y+1，于是最后变为 x - y -1&lt; 0，同时 -y = ~y +1，所以最后求的就是 x + ~y 的符号了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = (x&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = (y&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> diff = a &amp; (!b);<span class="comment">//不同符号时,仅x为负，为y为正时，为1</span></span><br><span class="line">  <span class="type">int</span> same = a ^ b;</span><br><span class="line">  <span class="type">int</span> temp = ((!same) &amp; (((x+~y)&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> diff | temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-logicalNeg"><a href="#9-logicalNeg" class="headerlink" title="9.logicalNeg"></a>9.logicalNeg</h2><p>&emsp;&emsp;这里要求我们通过使用允许的运算操作符：~  &amp;  ^  |  +  &lt;&lt;  &gt;&gt;  来实现逻辑非操作（!），即对于 x ，只要 x 不为0 ，那么就返回 0，否则返回 1。</p><p>&emsp;&emsp;首先，需要知道一个不为0的数与自己的相反数进行或运算会等于一个负数，0与自己的相反数进行或运算结果还是 0 ，并且一个负数右移31位后结果为 -1 ，而 0右移31位后则还是 0，最后再加上一个1，那么就都符合题目的需求了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = ~x+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ((x|a)&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-howManyBits"><a href="#10-howManyBits" class="headerlink" title="10.howManyBits"></a>10.howManyBits</h2><p>&emsp;&emsp;首先理解题意，要求求一个值使用补码来表示最少需要多少位。</p><p>通过对样例的分析可以得出结论，当 x 为正数时，在补码中位于最高位 1 之前的 0 是可以省略的，所以最少位数等于最高位 1 的位数加上 1 位符号位，而当 x 是一个负数时，同样的道理，位于最高位 0 之前的 1 也是可以省略的，所以此时最少位数等于最高位 0 的位数加上 1 位符号位，而对于 0 ，由于其补码没有符号位，所以表示只需 1 位。</p><p>&emsp;&emsp;按照上述过程，需要进行查找。为了方便统一，这里先将为负数的 x 取反，这样就和正数一样，只需找到最高位 1 后再加 1 位就行了，所以有如下操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sign = x&gt;&gt;<span class="number">31</span>;<span class="comment">//先取符号位。</span></span><br><span class="line">x = ((~sign) &amp; x) | (sign &amp; (~x));<span class="comment">//x为非负数则不变，x为负数则按位取反。</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来就是进行查找了，这里可以使用到二分的思想来进行查找，先看 x 最高的 16 位，将 x 进行右移 16 位，再将其规格化。</p><p>&emsp;&emsp;如果最高 16 位有 1 ，那么处理后的 x 就等于 1，故此时需要的位数至少为 16位，可以对该权值进行记录，只需要将处理后的 x 左移 4位，之后就对 <u>x 右移 16 位后的低16位</u>（注：此时的低16位就是原本 x 的高 16位）进行二分，将低 16 位中的高 8 位进行同样的操作，从而找到在 x 高16位中最高位 1。</p><p>&emsp;&emsp;如果没有 1 ，那么  x  处理后就等于 0 ，记录的值也等于 0 ，此时就不需要右移，而是在 x 的低 16 位中的高 8 位进行同样的操作。</p><p>&emsp;&emsp;综上，x 的右移操作可以总结为 x &gt;&gt; 本次记录的权值。以此类推，分别对高 8 位，4 位，2 位，1位进行同样操作。最后将所有权值进行相加，不要忘了在加一个 1 （对于非 0 数是加上 1 位的符号位，对于 0 是自己本身的 1 位。），此时就满足题目的要求了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sign = x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  x = ((~sign) &amp; x) | (sign &amp; (~x));</span><br><span class="line">  <span class="type">int</span> bit_16 = (!!(x&gt;&gt;<span class="number">16</span>))&lt;&lt;<span class="number">4</span>;</span><br><span class="line">  x = x &gt;&gt; bit_16;</span><br><span class="line">  <span class="type">int</span> bit_8 = (!!(x&gt;&gt;<span class="number">8</span>))&lt;&lt;<span class="number">3</span>;</span><br><span class="line">  x = x &gt;&gt; bit_8;</span><br><span class="line">  <span class="type">int</span> bit_4 = (!!(x&gt;&gt;<span class="number">4</span>))&lt;&lt;<span class="number">2</span>;</span><br><span class="line">  x = x &gt;&gt; bit_4;</span><br><span class="line">  <span class="type">int</span> bit_2 = (!!(x&gt;&gt;<span class="number">2</span>))&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  x = x &gt;&gt; bit_2;</span><br><span class="line">  <span class="type">int</span> bit_1 = (!!(x&gt;&gt;<span class="number">1</span>));</span><br><span class="line">  x = x&gt;&gt;bit_1;</span><br><span class="line">  <span class="type">int</span> bit_0 = x;</span><br><span class="line">  <span class="type">int</span> ans = bit_16+bit_8+bit_4+bit_2+bit_1+bit_0+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-floatScale2"><a href="#11-floatScale2" class="headerlink" title="11.floatScale2"></a>11.floatScale2</h2><p>&emsp;&emsp;从这里开始就属于浮点数运算部分，首先得了解一下IEEE浮点表示，在IEEE浮点标准中用</p><script type="math/tex; mode=display">V=(-1)^{s} \times M\times 2^{E}</script><p>&emsp;&emsp;来表示一个数。其中 符号 s 表示正负（s=0表示正数，s=1表示负数），尾数M 是一个<strong>二进制小数</strong>，阶码 E 是对浮点数的加权，权重为 2 的 E 次幂（可能为负数）。因此将浮点数的位表示划分为三个部分。<img src="/imgs/$%7BuseImgs%7D/img_4.png" alt=""></p><p>&emsp;&emsp;一个单独的符号位 s 直接编码符号 s 。（此 s 非彼 s）</p><p>&emsp;&emsp;k 位的阶码字段exp 来编码阶码 E。</p><p>&emsp;&emsp;n 位小数字段 frac 编码位数 M ，但是编码出来的值也依赖阶码字段的值是否等于 0 。</p><p>&emsp;&emsp;根据 exp 的值，被编码的值可以分成三种情况，最后一种情况有两个变种。<img src="/imgs/$%7BuseImgs%7D/img_5.png" alt=""></p><p>&emsp;&emsp;其中小数字段 frac 被解释为描述小数值 f ，0 ≤ f &lt;1 ，用二进制表示为</p><script type="math/tex; mode=display">f = 0.f_{n-1}...f_{1}f_{0}</script><p>&emsp;&emsp;当 exp 的位模式既不全为 0，又不全为 1 时，则属于规格化的值，总结如下</p><script type="math/tex; mode=display">Bias=2^{k-1}-1</script><script type="math/tex; mode=display">E=e-Bias</script><script type="math/tex; mode=display">M=1+f</script><p>&emsp;&emsp;当 exp 全为 0 时，则属于非规格的值，总结如下</p><script type="math/tex; mode=display">Bias=2^{k-1}-1</script><script type="math/tex; mode=display">E=1-Bias</script><script type="math/tex; mode=display">M=f</script><p>&emsp;&emsp;当 exp 全为 1 时，属于特殊值，其中当小数域全为 0 时，表示的是无穷（∞），按照 s 的正负分为 +∞ 与 -∞ ；当小数域不为 0 时，结果被称为“NaN”，即不是一个数。 </p><p>&emsp;&emsp;现在可以来看这一题了，题目需要我们求出浮点数* 2 之后的值。</p><p>&emsp;&emsp;首先依据IEEE浮点数分别求出单精度浮点数的符号位、阶码位以及小数位。由上面可知 float 是32位，一般 s 为 1 位，exp 为 8 位，frac 为 23 位。可以通过位运算来获得，如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned s = (uf&gt;&gt;31)&amp;1;</span><br><span class="line">unsigned e = (uf &amp; 0x7f800000)&gt;&gt;23;</span><br><span class="line">unsigned f = (uf &amp; 0x7fffff);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后根据上面的三种情况进行分析，即规格化的值、非规格化的值以及特殊值。其中，当为特殊值时，两种情况都是可以直接返回的。当为非规格化的值时，那么值就为 0 或无穷小，直接<em> 2返回就行，f 此时就是尾码，所以就直接 f &lt;&lt;= 1。当为规格化的值时， 由IEEE浮点表达式可知，只需要将exp+1，那么E也会 + 1，最终就会实现</em>2的效果。</p><p>&emsp;&emsp;所以最终解决方法如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> s = (uf&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> e = (uf &amp; <span class="number">0x7f800000</span>)&gt;&gt;<span class="number">23</span>;</span><br><span class="line">  <span class="type">unsigned</span> f = (uf &amp; <span class="number">0x7fffff</span>);</span><br><span class="line">  <span class="type">unsigned</span> ans;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//特殊值，直接返回</span></span><br><span class="line">  <span class="keyword">if</span>(e == <span class="number">0xff</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e == <span class="number">0</span>)&#123;<span class="comment">//非规格化</span></span><br><span class="line">      f &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      ans = (s&lt;&lt;<span class="number">31</span>)|(e&lt;&lt;<span class="number">23</span>)|f;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;<span class="comment">//规格化</span></span><br><span class="line">      e++;</span><br><span class="line">      ans = (s&lt;&lt;<span class="number">31</span>)|(e&lt;&lt;<span class="number">23</span>)|f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-floatFloat2Int"><a href="#12-floatFloat2Int" class="headerlink" title="12.floatFloat2Int"></a>12.floatFloat2Int</h2><p>&emsp;&emsp;这个函数让我们把一个给定的浮点数 uf 转换为 int 类型。因为 int 类型的范围相较于 float 小，所以会出现精度损失的情况。</p><p>首先还是和上一题一样，求出符号位 s ，阶吗 exp ，尾数 frac。再计算一下真实的阶数 E = exp - 127。如果 E &gt;=31 时，即为特殊值时，按照题目的要求返回 0x80000000u。 如果 E &lt; 0 时，即为非规格化的值时，此时 0&lt;= f &lt; 1，直接返回 0 。最后对于规格化的值，就按照正常处理，即</p><script type="math/tex; mode=display">V=(-1)^{s} \times M\times 2^{E}</script><p>&emsp;&emsp;先算出真实的尾数 M = frac | (1 &lt;&lt; 23)，同时 frac为23位，所以如果 E &gt;= 23则进行加权时，则要在frac的末尾加上（E - 23）个 0，若 E &lt; 23，则frac 末尾的（23-E）个数就无法保留，通过位运算可以实现。</p><p>&emsp;&emsp;同时还有一点需要注意，就是输入的数可能为负数，所以最后还需根据 s 的值进行判断。</p><p>&emsp;&emsp;最终代码如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="comment">//同样先获得符号s，尾数f，阶码e</span></span><br><span class="line">  <span class="type">unsigned</span> s = (uf&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x1</span>;</span><br><span class="line">  <span class="type">unsigned</span> e = (uf&gt;&gt;<span class="number">23</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">  <span class="type">unsigned</span> f = uf &amp; <span class="number">0x7fffff</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> E = e - <span class="number">127</span>;</span><br><span class="line">  <span class="keyword">if</span>(E&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(E &gt;= <span class="number">31</span>)<span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">      f = f | <span class="number">1</span>&lt;&lt;<span class="number">23</span>; </span><br><span class="line">      <span class="keyword">if</span>(E&lt;<span class="number">23</span>)&#123;</span><br><span class="line">           f &gt;&gt;= (<span class="number">23</span>-E);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           f &lt;&lt;= (E<span class="number">-23</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s)<span class="keyword">return</span> -f;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-floatPower2"><a href="#13-floatPower2" class="headerlink" title="13.floatPower2"></a>13.floatPower2</h2><p>&emsp;&emsp;这一题要求计算浮点数2.0^x。因为在浮点数中阶码表示的意义正好就是2的多少次幂，所以我们想到对阶码出手。</p><p>&emsp;&emsp;但是需要先导出浮点数规格化和非规格化分别表示的浮点数的范围。</p><p>&emsp;&emsp;对于非规格化的 E = 1-Bias = 1- 127 = -126，而M的最小值则为0.000…1，等于 $2^{-23}$，所以非规格化浮点的最小值为 2 的 -149 次方，M的最大值则等于 $1-2^{-23}$，所以非规格化的浮点最大为 $2^{-126}\times(1-2^{-23})$。</p><p>&emsp;&emsp;对于规格化的浮点，M的最小值为 1 ，E 的最小值为 1- 127 = -126，所以最小为 $2^{-126}$ 。M 的最大值为 1.111…11，E 的最大值为 127，故规格化的浮点最大值不到 $2^{128}$。</p><p>&emsp;&emsp;就可以得到下表</p><div class="table-container"><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th></tr></thead><tbody><tr><td style="text-align:center">规格化</td><td style="text-align:center">$2^{-126}$</td><td style="text-align:center">$2^{127}\times(2-2^{-23})$</td></tr><tr><td style="text-align:center">非规格化</td><td style="text-align:center">$2^{-149}$</td><td style="text-align:center">$2^{-126}\times(1-2^{-23})$</td></tr></tbody></table></div><p>&emsp;&emsp;所以</p><ol><li><p>x &gt; 127时，返回NaN 。</p></li><li><p>x &lt;= -149时，返回 0。</p></li><li><p>-126 &lt;= x &lt;= 127时，为规格化的，就直接让尾码全为0，控制阶码就可以了，由 x = expr - bias 可得 exp = x+ 127 。</p></li><li><p>-149  &lt; x &lt; -126时，为非规格化的，阶码值 E = 1 - bias = -126。这个时候只能通过控制尾码来计算。由 </p><script type="math/tex; mode=display">M\times2^{-126}=2^{x}</script><p>可以推断出 $M=2^{x+126}$ 。尾码的值是二次幂的形式，所以可以通过一个“1”左移获得，就可以设 1 左移了 n 位，则 $x+126 = -(23-n)$，等到n = x+ 149。</p><p>故最终解决方法如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">      * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment">      *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment">      *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment">      *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment">      *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment">      * </span></span><br><span class="line"><span class="comment">      *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment">      *   Max ops: 30 </span></span><br><span class="line"><span class="comment">      *   Rating: 4</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(x &lt; <span class="number">-149</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(x &lt;= <span class="number">-126</span>)<span class="keyword">return</span> <span class="number">1</span>&lt;&lt;(x+<span class="number">149</span>);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(x &lt;= <span class="number">127</span>)<span class="keyword">return</span> (x+<span class="number">127</span>) &lt;&lt; <span class="number">23</span>;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0xff</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h1><p>&emsp;&emsp;以上就是CSAPP DataLab的全部内容了，做完这个实验也算是对之前一段时间学习的一个巩固和练习吧，对于逻辑门运算和浮点运算也有了更多的了解。</p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
          <category> Lab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/10/08/hello-world/"/>
      <url>/2023/10/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
