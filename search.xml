<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[计算机网络]计算机网络体系框架</title>
      <link href="/2024/06/06/%5B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%5D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E6%A1%86%E6%9E%B6/"/>
      <url>/2024/06/06/%5B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%5D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：计算机网络体系框架"><a href="#第一章：计算机网络体系框架" class="headerlink" title="第一章：计算机网络体系框架"></a>第一章：计算机网络体系框架</h1><h2 id="1-1计算机网络的概念"><a href="#1-1计算机网络的概念" class="headerlink" title="1.1计算机网络的概念"></a>1.1计算机网络的概念</h2><p>&emsp;&emsp;什么是计算机网络？</p><p>&emsp;&emsp;<strong>计算机网络（computer networking）</strong>是一个将众多==分散的==、==自治的==计算机系统，通过==通信设备==与==线路==连接起来，由功能完善的==软件==实现==资源共享==和==信息传递==的系统。</p><p>&emsp;&emsp;计算机网络、互连网、互联网的区别？</p><p>&emsp;&emsp;计算机网络（简称 网络）：由若干==节点（node）==和连接这些结点的==链路（link）==组成。注：结点可以是计算机、集线器、交换机、路由器等。链路可以是有线链路、无线链路。</p><ol><li><p>集线器（Hub）：可以把多个节点连接起来，组成一个计算机网络。工作在物理层，会出现数据冲突，现已很少使用。</p></li><li><p>交换机（Switch）：可以把多个节点连接起来，组成一个计算机网络。工作在数据链路层，不会发生数据冲突。</p></li><li><p>路由器（router）：可以把==两个或多个计算机网络互相连接起来==，形成规模更大的计算机网络，也可称为==”互连网“==。工作在网络层。</p><p>Tips：计算机网络课程中的”路由器“和”家用路由器“有一些区别。==家用路由器 = 路由器 + 交换机 + 其他功能==。</p></li></ol><p><img src="/imgs/$%7BuseImgs%7D/image-20240506194823498.png" alt="image-20240506194823498"></p><p>&emsp;&emsp;这样，我们初步建立了下面的基本概念：</p><p>&emsp;&emsp;<u>网络把许多计算机连接在一起，而互连网则把许多网络通过一些路由器连接在一起。与网络相接的计算机常称为主机。</u></p><p>&emsp;&emsp;==互联网（或因特网，Internet）==把全球范围的计算机网络连接起来。</p><ol><li><p>==ISP==：<strong>Internet Service Provider</strong>，即互联网服务提供商。如：中国电信/移动/联通。</p></li><li><p>==互联网（或因特网，Internet）==由各大ISP和国际机构组建的，覆盖全球范围的<strong>互连网（Internet）</strong>。</p></li><li><p><strong>互联网</strong>必须使用==TCP/IP==协议通信，<strong>互连网</strong>可使用任意协议通信。注：“TCP/IP协议”即全球互联网结点遵守的通信协议。</p></li><li><p>==IXP==：<strong>Internet eXchange Point</strong>，即互联网交换点，主要作用为允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。</p><p><img src="/imgs/$%7BuseImgs%7D/image-20240506201631088.png" alt="image-20240506201631088"></p></li></ol><h2 id="1-2网络协议"><a href="#1-2网络协议" class="headerlink" title="1.2网络协议"></a>1.2网络协议</h2><p>&emsp;&emsp;硬件（主机、路由器、通信链路等）是计算机网络的基础。</p><p>&emsp;&emsp;计算机网络中的数据交换必须遵守事先约定好的==规则==。<strong>任何通信或信息交换过程都需要规则。</strong></p><p>&emsp;&emsp;什么是网络协议？</p><p>&emsp;&emsp;==网络协议（network protocol）==，简称为==协议==，是为进行网络中的数据交换而建立的规则、标准或约定。==协议==规定了通信实体之间所交换的信息的==格式、意义、顺序==以及针对收到信息或发生的事件所采取的==“动作”==（actions）。</p><p>&emsp;&emsp;协议三要素：</p><ol><li><p>语法（Syntax）：数据与控制信息的结构或格式。底层为信号电平。</p></li><li><p>语义（Semantics）：需要发出何种控制信息，完成何种动作以及做出何种响应。底层为差错控制</p></li><li><p>时序（Timing）：事件顺序。底层为速度匹配。</p></li></ol><p>&emsp;&emsp;==协议规范了网络中所有信息的发送和接受过程。==学习网络的重要内容之一，网络创新的表现形式之一，Internet协议标准。（大量的协议以RFC：Request for Comments文档的形式存在。由IETF：互联网工程任务组 Internet Engineering Task Force进行管理。）</p><h2 id="1-3计算机网络组成"><a href="#1-3计算机网络组成" class="headerlink" title="1.3计算机网络组成"></a>1.3计算机网络组成</h2><p>&emsp;&emsp;计算机网络大致可以分为以下几个部分：</p><ol><li>网络边缘：主机、网络应用。</li><li>接入网络，物理介质：有线或无线通信链路。</li><li>网络核心（核心网络）：互联的路由器（或分组转发设备），网络之网络。</li></ol><h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><ol><li>主机（端系统）：位于“网络边缘”，运行网络应用程序。<ul><li>==计算机之间的通信：指的是“主机A的某个进程和主机B上的另一个进程进行通信”==。</li></ul></li><li>客户/服务器（client/server）应用模型：客户发送请求，接收服务器响应。<ul><li>客户和服务器都是指通信中所涉及的两个应用进程。<strong>客户是服务请求方，服务器是服务提供方。</strong></li><li>客户与服务器的通信关系建立后，通信可以是双向的，客户和服务器都可以发送和接收数据。</li><li><strong>客户与服务器本来都指的是计算机进程（软件）。</strong></li></ul></li><li>对等（peer-peer，P2P）应用模型：无（或不仅依赖）专用服务器，通信在对等实体之间直接进行。</li></ol><h3 id="接入网络"><a href="#接入网络" class="headerlink" title="接入网络"></a>接入网络</h3><p>&emsp;&emsp;接入网络将网络边缘接入核心网络。可分为：</p><ol><li>家庭接入</li><li>机构接入</li><li>移动接入</li></ol><p>&emsp;&emsp;用户关心的为：</p><ol><li>带宽（bandwidth）（bps）：在网络中指的是数据传输速率。</li><li>共享/独占</li></ol><p>&emsp;&emsp;常见的接入网络：</p><ul><li><p>数字用户线路（DSL）：最典型为ADSL，即非对称，指上行速率与下行速率是不一样的。采用典型的频分多路复用技术（FDM）。</p><ul><li><p>利用==已有的==电话线连接中心局的DSLAM</p><ul><li>数据通信通过DSL电话线接入Internet。</li><li>语音（电话）通过DSL电话线接入电话网。</li></ul></li><li><p>&lt;2.5Mbps上行传输速率（典型速率&lt;1Mbps）</p></li><li>&lt;24Mbps下行传输速率（典型速率&lt;10Mbps）</li><li>==FDM==：&gt;50kHz - 1MHz用于下行。4kHz - 50kHz用于上行。0kHz - 4kHz用于传统电话。</li></ul><p><img src="/imgs/$%7BuseImgs%7D/image-20240506210301214.png" alt="image-20240506210301214"></p></li><li><p>电缆网络（cable modem）有线电视。</p><ul><li>频分多路复用：在不同频带（载波）上传输不同频道。</li><li>数据、电视信号在共享线缆分布式网络上，利用不同频率传输。</li><li>==HFC==：混合光纤同轴电缆（hybrid fiber coax)<ul><li>非对称：下行高达30Mbps传输速率，上行为2Mbps传输速率</li></ul></li><li>各家庭（设备）通过电缆网络→光纤接入ISP路由器<ul><li>各家庭==共享==家庭至电缆头端的==接入网络==</li><li>不同于DSL的==独占==至中心局的接入</li></ul></li></ul></li></ul><p><img src="/imgs/$%7BuseImgs%7D/image-20240506211559736.png" alt="image-20240506211559736"></p><ul><li><p>机构（企业）接入网络（Ethernet）</p><ul><li><p>主要用于公司、高校、企业等组织机构。</p></li><li><p>典型传输速率：10Mbps，100Mbps，1Gbps，10Gbps。</p></li><li>目前，端系统通常直接连接以太网（最常见的有线局域网）交换机。</li></ul></li></ul><p><img src="/imgs/$%7BuseImgs%7D/image-20240506212338180.png" alt="image-20240506212338180"></p><ul><li>无线接入网络<ul><li>通过==共享==的无线接入网络连接端系统于路由器<ul><li>通过==基站==（base station）或称为“==接入点==”（access point）。</li></ul></li><li>主要分为两类：<ul><li>无线局域网（LANs）：同意建筑物内（30m），802.11b/g（WiFi）</li><li>广域无线接入：通过电信运营商（蜂窝网），接入范围在几十公里。移动互联网。</li></ul></li></ul></li></ul><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>&emsp;&emsp;互联的路由器网络。网络核心的关键功能：路由+转发。</p><p>&emsp;&emsp;网络核心要向网络边缘部分中的大量主机提供连通性，使边缘部分中的任何一台主机都能够与其他主机通信。</p><p>&emsp;&emsp;在网络核心部分其特殊作用的是<strong>路由器</strong>（router），它是一种专用计算机（但不能称为主机）。路由器是实现<strong>分组交换</strong>的关键构件，其任务是<strong>转发收到的分组</strong>，这是网络核心部分最重要的功能。</p><p><img src="/imgs/$%7BuseImgs%7D/image-20240506213357307.png" alt="image-20240506213357307"></p><p>&emsp;&emsp;作为网络核心解决的基本问题：通过==数据交换==实现数据从源主机通过网络核心送达目的主机。</p><p>&emsp;&emsp;三种交换方式：</p><ul><li><p>电路交换</p><ul><li><p>经过  <strong>“建立连接”</strong>（占用通信资源）→<strong>“通话”</strong>（一直占用通信资源）→<strong>“释放连接”</strong>（归还通信资源）三个步骤的交换方式称为==电路交换==</p></li><li><p>其一个重要特点就是<strong>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源</strong>。</p></li><li><p>当使用电路交换来传送计算机数据时，其<strong>线路的传输效率往往很低</strong>。</p><p><img src="/imgs/$%7BuseImgs%7D/image-20240507154159168.png" alt="image-20240507154159168"></p></li></ul></li><li><p>报文交换</p><ul><li><p>通常我们把要发送的整块数据称为一个==报文==（message）。</p></li><li><p>电报通信也是采用了基于存储转发原理的报文交换。</p><p><img src="/imgs/$%7BuseImgs%7D/image-20240507154857574.png" alt="image-20240507154857574"></p></li></ul></li><li><p>分组交换</p><ul><li>在发送报文前，先把较长的报文划分为一个个更小的等长数据段。在每一个数据段前加上一些必要的控制信息组成的<strong>首部</strong>（header）后，就构成了一个<strong>分组</strong>（packet）。</li><li><p>分组又称为<strong>“包“</strong>，而分组的首部也可称为<strong>”包头“</strong>。</p></li><li><p>分组交换采用<strong>存储转发</strong>技术。</p></li><li>分组中的==”首部“==是非常重要的，正是由于分组的首部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立地选择传输路径，并被正确地交付到分组传输的终点。</li><li>位于网络边缘部分的主机和位于网络核心部分的路由器都是计算机，但它们的作用却很不一样。<ul><li><strong>主机是为用户进行信息处理的</strong>，并且可以和其他主机通过网络交换信息。</li><li><strong>路由器则用来转发分组，即进行分组交换</strong>。路由器收到一个分组，先暂时存储一下，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。</li></ul></li></ul></li></ul><p><img src="/imgs/$%7BuseImgs%7D/image-20240509215800450.png" alt="image-20240509215800450"></p><p>&emsp;&emsp;详细过程：<img src="/imgs/$%7BuseImgs%7D/image-20240510193346248.png" alt="image-20240510193346248"></p><p>注：</p><ol><li>假定在某一个分组的传送过程中，链路的通信量太大，那么路由器可以把分组沿另一个路由传送，即先转发到另一个路由器，在转发到其他路由器，最终把分组传送到目的主机。</li><li>路由器暂时存储的是一个个<strong>短分组</strong>，而不是整个的长报文。短分组是<strong>暂存在路由器的（即内存）</strong>中而不是存储在磁盘中的。这就保证了较高的<strong>交换速率</strong>。</li><li>实际上，互联网可以容许非常多的主机同时进行通信，而一台主机中的多个进程（即正在运行中的多道程序）也可以各自和不同主机中的不同进程进行通信。</li><li><strong>分组交换在传送数据之前不必先占用一条端到端的通信资源</strong>。只有当分组正在哪段链路上传送时，才会占用那段链路的通信资源，在各分组传送的空闲时间，该链路仍可以为其他主机发送的分组使用。</li><li>分组到达一个路由器后，先暂时存储下来，查找转发表，然后从另一条合适的链路转发出去。</li><li>分组在传输时就这样逐段地断续占用通信资源，而且还省去了建立连接和释放连接的开销，因而<strong>数据的传输效率更高</strong>。</li><li>互联网采取了专门的措施，保证了数据的传送具有了非常高的可靠性。当网络中的某些节点或链路突然出现故障时，在各路由器中运行的路由选择<strong>协议（protocol）</strong>能够自动找到转发分组最合适的路径。</li><li>采用存储转发的分组交换，==实质上是采用了在数据通信的过程中断续（或动态）分配传输带宽的策略。这对传送突发式的计算机数据非常合适，使得通信线路的利用率大大提高了。==</li><li>为提高分组交换网的可靠性，<strong>互联网的核心部分常采用网状拓扑结构</strong>，使得当发生网络拥塞或少数节点、链路出现故障时，路由器可灵活地改变转发路由而不导致引起通信的中断或全网的瘫痪。</li><li>此外，通信网络的主干线路往往由一些高速链路构成，这样就可以较高的数据率迅速地传送计算机数据。</li></ol><p>&emsp;&emsp;总上所述，分组交换的主要优点如下所示：</p><p><img src="/imgs/$%7BuseImgs%7D/image-20240510201347274.png" alt="image-20240510201347274"></p><p>&emsp;&emsp;分组交换的缺点：</p><ol><li>分组在各路由器存储转发时需要排队，这就会造成一定的<strong>时延</strong>。</li><li>各分组必须携带的控制信息造成了一定的<strong>开销</strong>（overhead）。整个分组交换网还需要专门的管理和控制机制。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>电路交换：整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。</p></li><li><p>报文交换：整个报文先传送到相邻节点，全部存储下来后查找转发表，转发到下一节点。</p></li><li><p>分组交换：单个分组（这只是整个报文的一部分）传送到相邻节点，存储下来后查找转发表，转发到下一个节点。</p><p><img src="/imgs/$%7BuseImgs%7D/image-20240510203605510.png" alt="image-20240510203605510.png"></p></li></ol><h2 id="1-4计算机网络的类别"><a href="#1-4计算机网络的类别" class="headerlink" title="1.4计算机网络的类别"></a>1.4计算机网络的类别</h2><h3 id="按照网络的作用范围进行分类"><a href="#按照网络的作用范围进行分类" class="headerlink" title="按照网络的作用范围进行分类"></a>按照网络的作用范围进行分类</h3><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">范围</th><th style="text-align:center">特点</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">广域网WAN（Wide Area Network）</td><td style="text-align:center">几十~几千公里</td><td style="text-align:center">互联网的核心部分，其任务是长距离运送主机所发送的数据。与其各节点交换机连接的链路一般都是高速链路，具有较大的通信容量。</td><td style="text-align:center">有时也称为远程网（long haul network）</td></tr><tr><td style="text-align:center">城域网MAN（Metropolitan Area Network）</td><td style="text-align:center">5~50公里</td><td style="text-align:center">可以为一个或多个单位所拥有，用来将多个局域网进行互连。目前很多城域网采用的是以太网技术，因此有时也常并入局域网的范围进行讨论。</td><td style="text-align:center">公用设施</td></tr><tr><td style="text-align:center">局域网LAN（Local Area Network）</td><td style="text-align:center">1公里左右</td><td style="text-align:center">一般用微型计算机或工作站通过高速通信线路相连。非常广泛的使用。</td><td style="text-align:center">学校或企业大都拥有多个互连的局域网（校园网或企业网）</td></tr><tr><td style="text-align:center">个人区域网PAN（Personal Area Network）</td><td style="text-align:center">10米左右</td><td style="text-align:center">把属于个人使用的电子设备用无线技术连接起来的网络，因此也常称为无线个人区域网WPAN。</td><td style="text-align:center">个人工作使用</td></tr></tbody></table></div><h3 id="按照网络的使用者进行分类"><a href="#按照网络的使用者进行分类" class="headerlink" title="按照网络的使用者进行分类"></a>按照网络的使用者进行分类</h3><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">特点</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">公用网（public network）</td><td style="text-align:center">指电信公司出资建造的大型网络。</td><td style="text-align:center">缴纳费用的人都可以使用，因此又称为公众网。</td></tr><tr><td style="text-align:center">专用网（private network）</td><td style="text-align:center">某个部门为满足本单位的特殊业务工作的需要而建造的网络。</td><td style="text-align:center">不向本单位以外的人提供服务。例如，军队、银行、铁路。</td></tr></tbody></table></div><h3 id="用来把用户接入到互联网的网络"><a href="#用来把用户接入到互联网的网络" class="headerlink" title="用来把用户接入到互联网的网络"></a>用来把用户接入到互联网的网络</h3><p>&emsp;&emsp;这种网络就是<strong>接入网</strong>AN（Access Network），又被称为<strong>本地接入网</strong>或<strong>居民接入网</strong>。即本地ISP所拥有的网络，既不属于互联网的核心部分，也不属于互联网的边缘部分。</p><h2 id="1-5计算机网络的性能"><a href="#1-5计算机网络的性能" class="headerlink" title="1.5计算机网络的性能"></a>1.5计算机网络的性能</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>&emsp;&emsp;计算机发送信号都是数字形式。</p><p>&emsp;&emsp;<strong>比特</strong>（bit）意为一个“<strong>二进制数字</strong>”，故一个比特就是二进制数字中的一个1或0。</p><p>&emsp;&emsp;比特也是信息论中使用的<strong>信息量的单位</strong>。网络技术中的<strong>速率</strong>指的是<strong>数据的传送速率</strong>，也称为<strong>数据率</strong>（data rate）或<strong>比特率</strong>（bit rate）。</p><p>&emsp;&emsp;速率单位是$bit/s$（比特每秒）（或$b/s$，有时也写为bps，即bit per second）。当数据较高时，就常常在$bit/s$前加上一个字母。如：k，M，G，T，P，E，Z，Y。</p><p>&emsp;&emsp;另外需要注意的是，当提到网络的速率时，往往指的是<strong>额定速率</strong>或<strong>标称速率</strong>，而并非网络实际上运行的速率。</p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>&emsp;&emsp;“<strong>带宽</strong>”（bandwidth）有以下两种不同的意义：</p><ol><li>带宽本来是指某个<strong>信号具有的频带宽度</strong>。信号的带宽是指该信号所包含的各种不同频带成分所占据的频率范围。这种意义的带宽的单位是<strong>赫</strong>（或<strong>千赫</strong>、<strong>兆赫</strong>、<strong>吉赫</strong>）。因此，表示某信道运行通过的信号频带范围就称为该信道的<strong>带宽</strong>（或<strong>通频带</strong>）</li><li>在计算机网络中，带宽用来表示网络中某<strong>通道</strong>传送数据的能力，因此网络带宽表示在单位时间内网络中的某信到所能通过的“<strong>最高数据库</strong>”。这种意义的<strong>带宽的单位</strong>就是<strong>数据率的单位</strong>$bit/s$是”<strong>比特每秒</strong>“。</li></ol><p>&emsp;&emsp;在“带宽”的上述两种表述中，前者为<strong>频域</strong>称谓，而后者为<strong>时域</strong>称谓，其本质是相同的。</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>&emsp;&emsp;<strong>吞吐量</strong>（throughput）表示在单位时间内通过某个网络（或信道、接口）的实际数据量。</p><p>&emsp;&emsp;吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p><p>&emsp;&emsp;接入到互联网的主机的实际吞吐量，取决于互联网的具体情况。</p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>&emsp;&emsp;<strong>时延</strong>（delay或latency）是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。时延有时也称为<strong>延迟</strong>或<strong>迟延</strong>。</p><p>&emsp;&emsp;网络中的时延是由以下几个不同的部分组成的：</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">定义</th><th style="text-align:center">公式</th></tr></thead><tbody><tr><td style="text-align:center">发送时延（transmission delay）</td><td style="text-align:center">又名传输延时，<strong>是主机或路由器发送数据帧所需要的时间</strong>。与发送的帧长（单位是比特）成正比，与发送速率成反比。</td><td style="text-align:center">$发送时延=\frac{数据帧长度（bit）}{发送速率（bit/s）}$</td></tr><tr><td style="text-align:center">传播时延（propagation delay）</td><td style="text-align:center"><strong>是电磁波在信道中传播一定的距离需要花费的时间</strong>。与信号的发送速率无关，与信号传送的距离有关，成正比。</td><td style="text-align:center">$传播时延=\frac{信道长度（m）}{电磁波子啊信道上的传播速率（m/s）}$</td></tr><tr><td style="text-align:center">处理时延（nodal processing delay）</td><td style="text-align:center">主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组首部、提取数据。</td><td style="text-align:center">\</td></tr><tr><td style="text-align:center">排队时延（queuing delay）</td><td style="text-align:center">分组在进入路由器后要先在输入队列中排队等待处理，当路由器确定了转发接口后，还要再输出队列中排队等待转发。这就产生了排队时延。</td><td style="text-align:center">\</td></tr></tbody></table></div><p>&emsp;&emsp;数据在网络中经历的总延时就是以上四种延时之和：$总延时=发送延时+传播延时+处理延时+排队延时$</p><p><img src="/imgs/$%7BuseImgs%7D/image-20240512201143142.png" alt="image-20240512201143142.png"></p><p>&emsp;&emsp;<strong>对于高速网络链路，我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率</strong>。荷载信息的电磁波在通信线路上的传播速率（这是光速的数据量级）取决于通信线路的介质材料，而与数据的发送速率无关。<strong>提高数据的发送速率只是减小了数据的发送时延</strong>。</p><p>&emsp;&emsp;数据的发送速率的单位是每秒发送多少个比特，这是指在<strong>某个点</strong>或<strong>某个接口上</strong>的发送速率。而传播速率的单位是每秒传播多少公里，是指在<strong>某一段传输线路上</strong>比特的传播速率。</p><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>&emsp;&emsp;将传播时延和带宽相乘，就得到了传播<strong>时延带宽积</strong>。即：$时延带宽积=传播时延\times带宽$</p><p>&emsp;&emsp;链路的时延带宽积又称为<strong>以比特为单位的链路长度</strong>。</p><p><img src="/imgs/$%7BuseImgs%7D/image-20240512203753442.png" alt="image-20240512203753442"></p><h3 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h3><p>&emsp;&emsp;在计算机网络中，<strong>往返时间RTT</strong>（Round-Trip Time）也是一个重要的性能指标。这是因为在许多情况下，互联网上的信息不仅仅单方向传输而是双向交互的。</p><p>&emsp;&emsp;在某些文献中，也有把RTT称为<strong>往返时延</strong>（Round-Trip Time delay）的，强调发送方至少要经过这样多的时间，才能知道自己所发送的数据是否被对方接收了。</p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>&emsp;&emsp;<strong>利用率</strong>有信道利用率和网络利用率两种。</p><ol><li>信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全闲置的信道的利用率是零。</li><li>网络利用率则是全网络的信道利用率的加权平均值。</li></ol><p>&emsp;&emsp;信道利用率并非是越高越好。这是因为，根据排队论的理论，当某些信道的利用率增大时，该信道引起的时延也就迅速增加。</p><p>&emsp;&emsp;当网络的通信量很少时，网络产生的时延并不大。但在网络通信量不断增大的情况下，由于分组在网络节点（路由器或节点交换机）进行处理时需要排队等候，因此网络引起的时延就会增大。</p><p>&emsp;&emsp;因此我们必须有这样的概念：<strong>信道利用率或网络利用率过高就会产生非常大的时延</strong>。</p><p><img src="/imgs/$%7BuseImgs%7D/image-20240512212547328.png" alt="image-20240512212547328"></p><h2 id="1-6计算机网络体系结构"><a href="#1-6计算机网络体系结构" class="headerlink" title="1.6计算机网络体系结构"></a>1.6计算机网络体系结构</h2><p>&emsp;&emsp;在计算机网络的基本概念中，<strong>分层次的体系架构（或架构）</strong>是最基本的。</p><h3 id="协议与划分层次"><a href="#协议与划分层次" class="headerlink" title="协议与划分层次"></a>协议与划分层次</h3><p>&emsp;&emsp;在计算机网络中要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则。<strong>这些规则明确规定了所交换的数据的格式以及有关的同步问题</strong>。</p><p>&emsp;&emsp;这里所说的<strong>同步</strong>不是狭义的（即同频或同频同相）而是广义的，即在一定的条件下应当发生什么事件，因而<strong>同步含有时序的意思</strong>。</p><p>&emsp;&emsp;这些<strong>为进行网络中的数据交换而建立的规则、标准或约定</strong>称为<strong>网络协议</strong>（network protocol）。也可简称为<strong>协议</strong>。网络协议主要有以下三个要素组成：</p><ol><li><strong>语法</strong>，即数据与控制信息的结构或格式。</li><li><strong>语义</strong>，即需要发出何种控制信息，完成何种动作以及做出何种响应。</li><li><strong>同步</strong>，即事件实现顺序的详细说明。</li></ol><p>&emsp;&emsp;任何我们想让连接在网络上的另一台计算机做点什么都需要网络协议。</p><p>&emsp;&emsp;对于非常复杂的计算机网络协议，其结构应该是层次式的。以网络传送文件为例。</p><p><img src="/imgs/$%7BuseImgs%7D/image-20240513202444526.png" alt="image-20240513202444526"></p><p>层次式的优点：</p><ol><li><strong>各层之间是独立的</strong>。某一层不用知道它的下一层是如何实现的，，只要知道该层通过层间的接口所提供的服务。</li><li><strong>灵活性好</strong>。各层之间不受影响。</li><li><strong>结构上可分割开</strong>。</li><li><strong>易于维护和实现</strong>。</li><li><strong>能促进标准化工作</strong>。</li></ol><p>因为分层式的设计，通常各层所要完成的功能主要有以下一些（可以只包括一种，也可以包括多种）：</p><ol><li><strong>差错控制</strong>：使相应层次对等方的通信更加可靠。</li><li><strong>流量控制</strong>：发送端的发送速率必须使接收端来得及接收，不要太快。</li><li><strong>分段和重装</strong>：发送端将要发送的数据块划分为更小的单位，在接收端将其还原。</li><li><strong>复用和分用</strong>：发送端几个高层会话复用一条低层的连接，在接收端再进行分用。</li><li><strong>连接建立和释放</strong>：交换数据前先建立一条逻辑连接，数据传送结束后释放连接。</li></ol><p>&emsp;&emsp;分层也有缺点，例如，有些功能在不同层次中重复出现，造成额外开销。</p><p>&emsp;&emsp;<strong>计算机网络的各层及其协议的集合</strong>就是网络的<strong>体系结构</strong>（architecture）。换种说法，<strong>计算机网络的体系结构就是这个计算机网络及其构件所应完成的功能的精确定义</strong>。</p><p>&emsp;&emsp;这些功能究竟是用何种硬件或软件完成的，则是一个遵循这种体系结构的<strong>实现</strong>的问题。<strong>体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件</strong>。</p><h3 id="具有五层协议的体系结构"><a href="#具有五层协议的体系结构" class="headerlink" title="具有五层协议的体系结构"></a>具有五层协议的体系结构</h3><p>&emsp;&emsp;OSI的七层协议体系结构的概念清楚，理论也比较完整，但复杂且不实用。</p><p>&emsp;&emsp;TCP/IP是一个四层的体系结构，包含应用层、运输层、网际层和链路层（网络接口层）。从实质上讲，TCP/IP只有最上面的三层，因为最下面的链路层并没有属于TCP/IP体系的具体协议。</p><p>&emsp;&emsp;在讲授计算机网络原理时往往采取另外的方法，即综合OSI和TCP/IP的优点，采用五层协议的体系结构。</p><p><img src="/imgs/$%7BuseImgs%7D/image-20240513205547668.png" alt="image-20240513205547668"></p><p>简单介绍下各层：</p><ol><li><p><strong>应用层</strong>（application layer）</p><ul><li>应用层是体系结构的最高层。应用层的任务是<strong>通过应用进程间的交互来完成特定网络应用</strong>。</li><li>应用层协议定义的是<strong>应用进程间通信和交互的规则</strong>。这里的<strong>进程</strong>就是指主机中<strong>正在运行的程序</strong>。</li><li>对于不同的网络应用需要有不同的应用层协议，例如域名系统DNS、支持万维网应用的HTTP协议、支持电子邮件的SMTP协议。</li><li>我们将应用层交互的数据单元称为<strong>报文</strong>（message）。</li></ul></li><li><p><strong>运输层</strong>（transport layer）</p><ul><li>运输层的任务就是负责向<strong>两台主机中进程之间的通信</strong>提供<strong>通用的数据传输服务</strong>。应用层进程利用该服务传送应用层报文。</li><li>由于一台主机可以同时运行多个进程，因此运输层有复用和分用的功能。复用即多个应用层进程可同时使用下面运输层的服务，分用则是运输层把收到的信息分别交付上面应用层中的相应进程。</li><li>运输层主要使用以下两种协议：<ul><li><strong>传输控制协议TCP</strong>（Transmission Control Protocol）——提供面向连接的、可靠的数据传输服务，其数据传输的单位是<strong>报文段</strong>（segment）</li><li><strong>用户数据报协议UDP</strong>（User Datagram Protocol）——提供无连接的<strong>尽最大努力</strong>（best-effort）的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是<strong>用户数据报</strong>。</li></ul></li></ul></li><li><p><strong>网络层</strong>（network layer）</p><ul><li>网络层负责为分组交换网上的不同<strong>主机</strong>提供通信服务。在发送数据时，~网络层把运输层产生的报文段或用户数据报封装成~<strong>分组</strong>或<strong>包</strong>进行传送。</li><li>在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为<strong>数据报</strong>。</li><li><strong>无论在那一层传送的数据单元，都可以笼统地用“分组”来表示</strong>。但各层之间需分清楚，不要混淆。</li><li>具体任务有两个。第一个：通过一定<strong>算法</strong>，在互联网中的每一个路由器上生成一个用来<strong>转发分组的转发表</strong>。第二个：在每一个路由器接收到一个分组时，依据转发表中指明的路径把分组转发到下一个路由器。</li><li>互联网是由大量的<strong>异构</strong>（heterogeneous）网络通过<strong>路由器</strong>（router）相互连接起来的。互联网使用的网络层协议是无连接的<strong>网际协议IP</strong>（Internet Protocol）和许多种路由器选择协议，因此互联网的网络层也叫作<strong>网际层</strong>或<strong>IP层</strong>。</li></ul></li><li><p><strong>数据链路层</strong>（data link layer）</p><ul><li>数据链路层简称为<strong>链路层</strong>。两台主机之间的数据传输，总是在一段段的链路上传送的，这就需要使用专门的链路层的协议。</li><li>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报<strong>组装成帧</strong>（framing），在两个相邻节点间的链路送帧（frame）。</li><li>每一帧包括数据和必要的<strong>控制信息</strong>（如同步信息、地址信息、差错控制等）。控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。同时还能判使接收端检测收到的帧有无差错，若有，则简单地丢弃。</li></ul></li><li><strong>物理层</strong>（physical layer）</li></ol><ul><li>在物理层上所传送数据的单位是==比特==。为保证发送与接收的信息相同，物理层需要考虑电缆、电压等物理规定。<ul><li>用于传递信息所的一些物理传输媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内，而是在物理层协议下面。</li><li>现在经常提起的TCP/IP并不是单指TCP和IP这两个具体的协议，而往往是代表互联网所使用的整个<strong>TCP/IP协议族</strong>（protocol suite）。</li></ul></li></ul><p>数据传输详细过程：</p><ol><li>主机1将数据交给本主机的第5层（应用层）。</li><li>第5层加上必要的控制信息H~5~就变成了下一层（运输层）的数据单元。</li><li>第4层（运输层）收到这个数据单元后，加上本层的控制信息H~4~，再交给第3层（网络层），成为第3层的数据单元。</li><li>以此类推。不过到了==第2层（数据链路层）==后，==控制信息被分成了两部分==，分别加到本层数据单元的首部（H~2~）和尾部（T~2~）。</li><li>由于第1层（物理层）是比特流的传送，所以不再加上控制信息。注：==传送比特流时应从首部开始传送==。</li><li>当比特流离开主机1，经过网络的物理传输媒体传送到路由器时，就从==路由器的第1层依次上升到第3层==。</li><li>每一层都根据控制信息进行必要的操作，然后将控制信息剥离，将该层剩下的数据单元上交给更高的一层。</li><li>上升到第3层网络层时，就根据首部中的==目的地址==查找路由器中的转发表，找出转发分组的接口。</li><li>然后向下传送到第2层，加上新的首部和尾部后，再到最下面的第1层，然后在物理传输媒体上把每一个比特发送出去。</li><li>当这一串比特流离开路由器到达目的站主机2时，就从主机2的第1层按照一样的方式，依次上升到第5层。</li></ol><p><img src="/imgs/$%7BuseImgs%7D/image-20240514153059372.png" alt="image-20240514153059372"></p><p>&emsp;&emsp;由于该复杂过程对用户屏蔽，所以任何两个同样的层次之间，似乎是直接传递给对方，这就是所谓的“<strong>对等层</strong>”（peer layers）之间的通信。我们所说的各层协议，实际上就是在各个对等层之间传递数据时的各项规定。</p><p>&emsp;&emsp;OSI参考模型把对等层次之间传送的数据单元称为该层的<strong>协议数据单元</strong>PDU（Protocol Data Unit）。</p><h3 id="实体、协议、服务和服务访问点"><a href="#实体、协议、服务和服务访问点" class="headerlink" title="实体、协议、服务和服务访问点"></a>实体、协议、服务和服务访问点</h3><p>&emsp;&emsp;当研究开放系统中的信息交换时，往往使用<strong>实体</strong>（entity）这一较为抽象的名词表示==任何可发送或接收信息的硬件或软件进程==。在许多情况下，实体就是一个特定的软件模块。</p><p>&emsp;&emsp;<strong>协议是控制两个对等实体</strong>（或<strong>多个实体</strong>）<strong>进行通信的规则的集合</strong>。</p><p>&emsp;&emsp;<strong>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务</strong>。</p><p>&emsp;&emsp;一定要弄清楚，协议和服务在概念上是很不一样的。</p><ol><li>协议的实现保证了能够向上一层提供服务。<strong>使用本层服务的实体只能看见服务而无法看见下面的协议</strong>。也就是说，<strong>下面的协议对上面的实体是透明的</strong>。</li><li>协议是<strong>”水平的“</strong>，即协议是控制==对等实体==之间通信的规则。但是<strong>服务是“垂直的”</strong>，即服务是由下层向上层通过层间接口提供的。</li><li>另外，并非在一个层内完成的全部功能都称为服务，只有被高一层实体<strong>“看得见”</strong>的功能才能称之为“服务”。上层使用下层提供的服务必须通过与下层交换一些命令，这些命令在OSI中称为<strong>服务原语</strong>。</li></ol><p>&emsp;&emsp;在同一系统中相邻的两层的实体进行交互（即交换信息）的地方，通常称为==服务访问点==<strong>SAP（Service Access Point）</strong>。服务访问点SAP是一个抽象的概念，实际上就是一个逻辑接口，但这种层间的接口和两个设备之间的硬件接口（并行的或串行的）并不一样。OSI将层与层之间交换的数据的单位称为<strong>服务数据单元SDU（Service Data Unit）</strong>，它可以与PDU不一样。</p><p>&emsp;&emsp;这样，在任何相邻两层之间的关系均可以概括为下图</p><p><img src="/imgs/$%7BuseImgs%7D/image-20240514161301155.png" alt="image-20240514161301155"></p><p>&emsp;&emsp;计算机网络的协议还有一个很重要的特点，即==协议必须把所有不利的条件事先都估计到，而不能假定一切都是正常的和非常理想的==。</p><p>&emsp;&emsp;因此，看一个计算机网络协议是否在正确，不能只看正常情况下是否正确，还必须<strong>非常仔细地检查协议能否应付任何一种出现概率极小的异常情况</strong>。</p><h3 id="TCP-IP的体系结构"><a href="#TCP-IP的体系结构" class="headerlink" title="TCP/IP的体系结构"></a>TCP/IP的体系结构</h3><p>&emsp;&emsp;TCP/IP的体系结构比较简单，它只有四层。</p><p><img src="/imgs/$%7BuseImgs%7D/image-20240514163055461.png" alt="image-20240514163055461"></p><p>&emsp;&emsp;在现在的互联网使用的TCP/IP体系结构有时已经演变为下图所示：</p><p><img src="/imgs/$%7BuseImgs%7D/image-20240514163224074.png" alt="image-20240514163224074"></p><p>&emsp;&emsp;这个体系结构没有清晰地阐明区分开服务、接口和协议之间的关系，而且链路层并非真正的一个层次，而仅仅强调了IP层需要这样一个与网络的接口。这个体系结构没有把重要的物理层和链路层包含进来。</p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[深入理解计算机系统]CSAPP 第四章学习笔记</title>
      <link href="/2023/12/11/%5B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%5DCSAPP%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/11/%5B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%5DCSAPP%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解计算机系统-CSAPP-第四章学习笔记"><a href="#深入理解计算机系统-CSAPP-第四章学习笔记" class="headerlink" title="[深入理解计算机系统]CSAPP 第四章学习笔记"></a>[深入理解计算机系统]CSAPP 第四章学习笔记</h1><p>&emsp;&emsp;本人仍处于学习中，若有错误，恳请谅解。这里推荐一个B站宝藏UP主——九曲阑干，看他的视频给了我许多帮助，也希望可以帮助到你。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="指令集体系结构是什么"><a href="#指令集体系结构是什么" class="headerlink" title="指令集体系结构是什么"></a>指令集体系结构是什么</h3><p>&emsp;&emsp;处理器必须执行一系列指令，每条指令执行某个简单操作，如两个数相加。每一条指令会被编码为由一个或多个字节序列组成的二进制格式，即能被处理器识别的机器码。</p><p>&emsp;&emsp;<strong>一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构——ISA</strong>，也就是指令集架构、指令系统结构。</p><h3 id="指令集体系结构的作用"><a href="#指令集体系结构的作用" class="headerlink" title="指令集体系结构的作用"></a>指令集体系结构的作用</h3><p>&emsp;&emsp;指令集体系结构（ISA）是计算机软件和硬件交互的接口。</p><p>&emsp;&emsp;ISA 在编译器编写者（CPU软件）和处理器设计人员（CPU硬件）之间提供了一个概念抽象层，编译器编写者只需要知道允许那些指令，以及它们是如何编码的（即依据ISA了解CPU选用的指令集，明白可以使用那些指令，同时要遵循哪些规范）；而处理器设计者必须建造出执行这些指令的处理器（依据ISA来设计处理器）。</p><p>&emsp;&emsp;<strong>ISA最重要的内涵就是定义处理器上的软件如何构建。</strong></p><p>&emsp;&emsp;注：<strong>指令集并不储存于CPU中，事实是CPU本身是指令集体系结构（ISA）的一个实现实例。同时一个ISA可能有多个指令集。</strong></p><h3 id="Y86-64"><a href="#Y86-64" class="headerlink" title="Y86-64"></a>Y86-64</h3><p>&emsp;&emsp;本章定义了一个简单的指令集，通过x86-64的启发，所以命名为“Y86-64”。Y86-64不像x86-64那样复杂，该指令集的数据类型、指令和寻址方式都要少一些，并且字节级编码也比较简单。但是仍然足够完整。</p><h3 id="数字硬件设计"><a href="#数字硬件设计" class="headerlink" title="数字硬件设计"></a>数字硬件设计</h3><p>&emsp;&emsp;了解处理器中使用的基本构件块，以及它们如何连接起来和操作的。同时介绍一种描述硬件系统控制部分的简单语言——HCL。通过学习，具有对硬件逻辑设计的背景知识。</p><h3 id="顺序设计处理器"><a href="#顺序设计处理器" class="headerlink" title="顺序设计处理器"></a>顺序设计处理器</h3><p>&emsp;&emsp;给出一个基于顺序操作、功能正常但是有点不太实用的 Y86-64 处理器。该处理器每个时钟内可以执行一条完整的 Y86-64 指令。所以它的时钟必须足够慢，以允许在一个周期内完成所有动作。</p><h3 id="流水线化处理器"><a href="#流水线化处理器" class="headerlink" title="流水线化处理器"></a>流水线化处理器</h3><p>&emsp;&emsp;以顺序设计为基础，我们进行升级改造，创建一个流水化线的处理器。</p><h2 id="Y86-64指令集体系结构"><a href="#Y86-64指令集体系结构" class="headerlink" title="Y86-64指令集体系结构"></a>Y86-64指令集体系结构</h2><h3 id="程序员可见的状态"><a href="#程序员可见的状态" class="headerlink" title="程序员可见的状态"></a>程序员可见的状态</h3><p>&emsp;&emsp;什么是程序员的可见状态？</p><p>&emsp;&emsp;首先，这里的程序员既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器。</p><p>&emsp;&emsp;其次，可见状态是指<strong>每一条指令都会去读取或修改处理器的某些部分</strong>。例如内存、寄存器、条件码、程序计数器以及程序状态等。</p><p>&emsp;&emsp;在Y86-64指令系统中，我们定义了15个64位的程序寄存器，相较于第三章中熟悉的x86-64的指令系统少了一个 %r15 ，是为了降低指令编码的复杂度。每个程序寄存器存储一个64位的字。寄存器 %rsp 被入栈、出栈、调用和返回指令作为栈指针。其余的没有固定的含义或固定值。</p><p>&emsp;&emsp;同时Y86-64的指令系统还简化了条件码寄存器，只有 3 个一位的条件码：ZF、SF、OF，它们保存着最近的算术或逻辑指令所造成影响的有关信息。</p><p>&emsp;&emsp;<strong>程序计数器（PC）是用来存放当前正在执行指令的地址。</strong></p><p>&emsp;&emsp;然后关于内存，从概念上来说，内存实际上就是一个很大的字节数组，保存着程序和数据。Y86-64 程序采用 <strong>虚拟地址</strong> 来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或 <strong>物理地址</strong> ，指明数据实际存在内存中哪个地方。</p><p>&emsp;&emsp;最后就是程序状态了，程序状态的最后一个部分是状态码Stat，它是用来表明程序执行的总状态。是正常运行呢，还是出现了异常。</p><p><img src="/imgs/$%7BuseImgs%7D/img_11.png" alt=""></p><h3 id="Y86-64指令"><a href="#Y86-64指令" class="headerlink" title="Y86-64指令"></a>Y86-64指令</h3><p>&emsp;&emsp;类比x86-64的指令集，Y86-64指令集做了一些相应的简化。</p><h4 id="1-数据传送指令"><a href="#1-数据传送指令" class="headerlink" title="1.数据传送指令"></a>1.数据传送指令</h4><p>&emsp;&emsp;x86-64中的 movq 指令分成了4个不同的指令：irmovq 、rrmovq 、mrmovq 和 rmmovq，分别显示地指明源和目的的格式。</p><p>&emsp;&emsp;指令名字的第一个字母表明源操作数的类型，第二个字母表明目的操作数的类型。</p><p>&emsp;&emsp;源操作数可以是立即数（i：immediate）、寄存器（r：register)、内存（m：memory），而目的操作数可以是寄存器（r：register）、内存（m：memory）。</p><p><img src="/imgs/$%7BuseImgs%7D/img_7.png" alt=""></p><p>&emsp;&emsp;注：两个内存传送指令（mrmovq、rmmovq）中的内存引用方式是简单的基址和偏移量形式。同时，在地址计算中，不支持第二变址寄存器和任何寄存器的伸缩。</p><p>&emsp;&emsp;与x86-64一样，不允许从一个内存地址直接传送到另一个内存地址。另外，也不允许将立即数传送到内存。</p><h4 id="2-整数操作指令"><a href="#2-整数操作指令" class="headerlink" title="2.整数操作指令"></a>2.整数操作指令</h4><p>&emsp;&emsp;在Y86-64中，我们有4个整数操作指令，它们是addq、subq、andq 和 xorq。它们只对寄存器数据进行操作，而x86-64还允许对内存数据进行这些操作。这些指令会设置 3 个条件码 ZF 、SF  和 OF（零、符号和溢出）。其字节级编码如下：</p><p><img src="/imgs/$%7BuseImgs%7D/img_8.png" alt=""></p><h4 id="3-跳转指令"><a href="#3-跳转指令" class="headerlink" title="3.跳转指令"></a>3.跳转指令</h4><p>&emsp;&emsp;在Y86-64中，我们有7个跳转指令，分别是 jmp 、jle 、jl 、je、jne、jge 和 jg。根据分支指令的类型和条件代码的设置来选择分支。分支条件和 x86-64 一样。如下图所示：</p><p><img src="/imgs/$%7BuseImgs%7D/img_12.png" alt=""></p><h4 id="4-条件传送指令"><a href="#4-条件传送指令" class="headerlink" title="4.条件传送指令"></a>4.条件传送指令</h4><p>&emsp;&emsp;在 Y86-64 中，我们定义了6个条件传送指令：comvle、cmovl、cmove、cmovne、cmovge、cmovg。这些指令的格式与寄存器-寄存器传送指令 rrmovq 一样，<strong>但是只有当条件代码满足所需要的约束时，才会更新目的寄存器的值。</strong></p><p>&emsp;&emsp;其字节级编码如下：<img src="/imgs/$%7BuseImgs%7D/img_15.png" alt=""></p><h4 id="5-其他指令"><a href="#5-其他指令" class="headerlink" title="5.其他指令"></a>5.其他指令</h4><p>&emsp;&emsp;call指令会将返回地址入栈，然后跳到目的地址。ret 指令从这样的调用中返回。</p><p>&emsp;&emsp;pushq 和 popq 指令实现了入栈和出栈，就像在 x86-64 中一样。</p><p>&emsp;&emsp;halt 指令停止指令的执行。x86-64 中有一个与之相当的指令 hlt。x86-64 的应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。对于 Y86-64 来说，执行halt 指令会导致处理器停止，并将状态码设置为 HLT 。</p><p>&emsp;&emsp;其字节级编码如下：<img src="/imgs/$%7BuseImgs%7D/img_16.png" alt=""></p><h3 id="指令编码"><a href="#指令编码" class="headerlink" title="指令编码"></a>指令编码</h3><p><img src="/imgs/$%7BuseImgs%7D/img_6.png" alt=""></p><p>&emsp;&emsp;上图给出了上述指令的字节级编码。每条指令需要1~10个字节不等，这取决于需要哪些字段。</p><ol><li><p>每条指令的第一个字节表明指令的类型。</p></li><li><p>该字节分为两部分，每一部分占4个比特位，高四位表示指令代码，低四位表示指令功能。</p></li><li><p>不同的指令代码表示不同的指令，指令的功能部分都为 0 。</p></li><li><p>当指令中有寄存器类型的操作数时，回附加一个字节，该字节被称为寄存器指示符字节，用于指定一个或者两个寄存器，因此还需要对寄存器进行编码。</p></li><li><p>Y86-64指令系统中，我们定义了15个寄存器，每个寄存器不仅定义了名字，还为每一个寄存器指定一个编号。使用十六进制数 0 ~ 0xE 来表示。</p></li></ol><p><img src="/imgs/$%7BuseImgs%7D/img_13.png" alt=""></p><p>&emsp;&emsp;<strong>指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。</strong></p><h3 id="Y86-64-异常"><a href="#Y86-64-异常" class="headerlink" title="Y86-64 异常"></a>Y86-64 异常</h3><p>&emsp;&emsp;对 Y86-64 来说，程序员可见状态包括状态码 Stat ，它描述程序执行的总体状态。这个代码可能的值如下图所示：</p><p><img src="/imgs/$%7BuseImgs%7D/img_14.png" alt=""></p><p>出现某种异常时，Stat 的值会变为相对应的值，同时也会被命名为相对应的名字。在遇到这些异常的时候，我们就只是简单的让处理器停止执行指令。</p><h3 id="Y86-64-程序"><a href="#Y86-64-程序" class="headerlink" title="Y86-64 程序"></a>Y86-64 程序</h3><p>&emsp;&emsp;x86-64代码是由GCC编译器产生的。Y86-64代码与之类似，但又以下不同点：</p><ul><li>Y86-64将常数加载到寄存器（第2~6行），因为它在算术指令中不能使用立即数。</li><li>要实现从内存读取一个数值并将其与一个寄存器相加，Y86-64代码需要两条指令（第8~9行），而x86-64只需要一条 addq 指令（第5行）。</li><li>手工编写的Y86-64实现有一个优势，即 subq 指令（第11行）同时还设置了条件码，因此GCC生成代码中的 testq 指令（第9行）就不是必需的。不过为此，Y86-64必须使用 andq 指令（第5行）在进入循环之前设置条件码。</li></ul><p><img src="/imgs/$%7BuseImgs%7D/img_17.png" alt=""></p><p>&emsp;&emsp;程序寄存器：从本质上来讲它属于处理器内部的存储单元，通常我们将寄存器的集合称为寄存器文件，有的资料中也称寄存器堆。</p><p>&emsp;&emsp;在处理器内部，寄存器文件和算术逻辑单元（ALU）是串联的，寄存器文文件的输出端口与 ALU 的输入端口相连。</p><p><img src="/imgs/$%7BuseImgs%7D/img_18.png" alt=""></p><p>&emsp;&emsp;下图展示了一个寄存器文件的功能表述：</p><ul><li>具有一个读端口和一个写端口，数据位宽为64位。</li><li>规定读写操作共用地址线，由于定义了15个程序寄存器，故地址线宽度设计成4位即可满足寻址要求。</li><li>此外，还有时钟信号、复位信号以及写使能信号。</li></ul><p><img src="/imgs/$%7BuseImgs%7D/img_19.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android]Jetpack Compose 实现仿裸眼3D</title>
      <link href="/2023/11/25/%5BAndroid%5DJetpack%20Compose%20%E5%AE%9E%E7%8E%B0%E4%BB%BF%E8%A3%B8%E7%9C%BC3D/"/>
      <url>/2023/11/25/%5BAndroid%5DJetpack%20Compose%20%E5%AE%9E%E7%8E%B0%E4%BB%BF%E8%A3%B8%E7%9C%BC3D/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;最近在学传感器的时候，看到了有大佬使用 Jetpack Compose 实现了一个仿裸眼3D的效果，十分的牛皮，看得我是心血来潮、热血澎湃，这里放上推荐链接：<a href="https://juejin.cn/post/6992169168938205191">Compose版来啦！仿自如裸眼3D效果 - 掘金 (juejin.cn)</a>。于是就也想拥有，所以按照大佬的思路，使用Android 传感器中的陀螺仪来进行一个实现。同时也可以去了解一下 Android 中传感器（Sensor）的使用，这里送上官方传感器文档：<a href="https://developer.android.google.cn/guide/topics/sensors?hl=zh-cn">传感器  | Android 开发者  | Android Developers (google.cn)</a>。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>&emsp;&emsp;根据上方大佬的思路，我们可以很好地理解的这个仿裸眼3D的原理，简单来说，就是将一张图进行抠图，将其分为前、中、后三个图层（也可以是自己找的三个元素），然后使用 Canvas 里面的 drawImage 函数将三张图画出（使用这个方法加载图片方便进行位移）。</p><p>&emsp;&emsp;接着对前、后图层使用 translate 函数，通过设置位移量来实现图层的移动，所以只需要通过改变位移量就可以对图片进行位移。这里要注意，要实现仿裸眼3D，就需要在前层图片往一个方向移动时，后层图片向另一个方向移动，中层图片则不动，所以对于前层和后层的 translate 函数的传值要对应取反。</p><p>&emsp;&emsp;于是现在就需要实现在翻转手机时，为 translate 函数提供相应的位移量。就使用到了陀螺仪传感器，在转动手机时，传感器会传回 x、y、z 三个方向（判断方向如下图所示）的角速度，往正方向翻转会传回一个正的角速度，往负方向翻转会传回一个负的角速度。</p><p><img src="/imgs/$%7BuseImgs%7D/img_9.png" alt=""></p><p>&emsp;&emsp;得到了这个方向上的角速度，就可以由一个基本的物理公式 $\omega = \frac{<em>{\Delta }\Theta  }{</em>{\Delta}t} $ 求出所转过的角度（rad）是多少（若不熟悉弧度制，可使用 Math 库中的 Degress 函数将弧度制转化为角度制），然后和大佬思路一致，设置最大角度和最大平移距离（可以根据自己的），通过</p><script type="math/tex; mode=display">{\color{Violet} \frac{旋转角度}{最大旋转角度} = \frac{平移距离}{最大平移距离}}</script><p>求出该旋转角度下图片的平移距离。</p><p>&emsp;&emsp;为了获取角度值，就需要得到时间，不用担心，在官方文档介绍陀螺仪的部分中，其示例中就有对时间的积累，即获取时间。如下</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> NS2S <span class="token operator">=</span> <span class="token number">1.0f</span> <span class="token operator">/</span> <span class="token number">1000000000.0f</span><span class="token keyword">var</span> timestamp<span class="token operator">:</span> Float <span class="token operator">=</span> <span class="token number">0f</span>sensorManager<span class="token punctuation">.</span><span class="token function">registerListener</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> SensorEventListener<span class="token punctuation">&#123;</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onSensorChanged</span><span class="token punctuation">(</span>event<span class="token operator">:</span> SensorEvent<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// This timestep's delta rotation to be multiplied by the current rotation</span>            <span class="token comment">// after computing it from the gyro sample data.</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>timestamp <span class="token operator">!=</span> <span class="token number">0f</span> <span class="token operator">&amp;&amp;</span> event <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">val</span> dT <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>timestamp <span class="token operator">-</span> timestamp<span class="token punctuation">)</span> <span class="token operator">*</span> NS2S                <span class="token comment">/*                *中间省略大部分                */</span>            <span class="token punctuation">&#125;</span>            timestamp <span class="token operator">=</span> event<span class="token operator">?</span><span class="token punctuation">.</span>timestamp<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">toFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?:</span> <span class="token number">0f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可以开始实操了。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="三层图片绘制"><a href="#三层图片绘制" class="headerlink" title="三层图片绘制"></a>三层图片绘制</h2><p>&emsp;&emsp;按照上面的思路，首先需要有三层的图片，然后把他们绘制在一起，然后对前层与后层的图片加上 translate 函数用于平移。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">const</span> <span class="token keyword">val</span> NS2S <span class="token operator">=</span> <span class="token number">1.0f</span> <span class="token operator">/</span> <span class="token number">1000000000.0f</span><span class="token keyword">private</span> <span class="token keyword">var</span> timestamp <span class="token operator">:</span> Float <span class="token operator">=</span> <span class="token number">0f</span><span class="token keyword">private</span> <span class="token keyword">const</span> <span class="token keyword">val</span> maxAngle <span class="token operator">:</span> Float <span class="token operator">=</span> <span class="token number">60f</span>          <span class="token comment">//设置最大角度，我使用的是角度制</span><span class="token keyword">private</span> <span class="token keyword">const</span> <span class="token keyword">val</span> maxOffset <span class="token operator">:</span> Float <span class="token operator">=</span> <span class="token number">100f</span>        <span class="token comment">//设置最大平移距离  </span><span class="token annotation builtin">@Composable</span><span class="token keyword">fun</span> <span class="token function">ClassFree3D</span><span class="token punctuation">(</span>    sensorManager<span class="token operator">:</span> SensorManager<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> imageBack <span class="token operator">=</span> ImageBitmap<span class="token punctuation">.</span><span class="token function">imageResource</span><span class="token punctuation">(</span>id <span class="token operator">=</span> R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>imgback<span class="token punctuation">)</span>    <span class="token keyword">val</span> imageMid <span class="token operator">=</span> ImageBitmap<span class="token punctuation">.</span><span class="token function">imageResource</span><span class="token punctuation">(</span>id <span class="token operator">=</span> R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>imgmid<span class="token punctuation">)</span>    <span class="token keyword">val</span> imageFore <span class="token operator">=</span> ImageBitmap<span class="token punctuation">.</span><span class="token function">imageResource</span><span class="token punctuation">(</span>id <span class="token operator">=</span> R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>imgfore<span class="token punctuation">)</span>        <span class="token keyword">var</span> xDistance <span class="token keyword">by</span> remember <span class="token punctuation">&#123;</span> <span class="token function">mutableFloatStateOf</span><span class="token punctuation">(</span><span class="token number">0f</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">var</span> yDistance <span class="token keyword">by</span> remember <span class="token punctuation">&#123;</span> <span class="token function">mutableFloatStateOf</span><span class="token punctuation">(</span><span class="token number">0f</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>    <span class="token function">Box</span><span class="token punctuation">(</span>modifier <span class="token operator">=</span> Modifier<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">Canvas</span><span class="token punctuation">(</span>            modifier <span class="token operator">=</span> Modifier                <span class="token punctuation">.</span><span class="token function">fillMaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">//通过设置scale设置图片边界，防止在平移过程中图片平移过大导致露出屏幕背景</span>                <span class="token punctuation">.</span><span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">1.3f</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">translate</span><span class="token punctuation">(</span><span class="token operator">-</span>yDistance<span class="token punctuation">,</span><span class="token operator">-</span>xDistance<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">//对于前层取反，实现反向移动</span>                <span class="token function">drawImage</span><span class="token punctuation">(</span>imageBack<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            <span class="token function">drawImage</span><span class="token punctuation">(</span>                image <span class="token operator">=</span> imageMid<span class="token punctuation">,</span>                <span class="token comment">//这里通过 drawImage 同时对图片进行一个定位，使三张图片组合得好看</span>                dstOffset <span class="token operator">=</span> <span class="token function">IntOffset</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">,</span>y <span class="token operator">=</span> <span class="token number">350</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                dstSize <span class="token operator">=</span> <span class="token function">IntSize</span><span class="token punctuation">(</span>width <span class="token operator">=</span> imageMid<span class="token punctuation">.</span>width <span class="token operator">-</span> <span class="token number">1000</span><span class="token punctuation">,</span> height <span class="token operator">=</span> imageMid<span class="token punctuation">.</span>height <span class="token operator">-</span> <span class="token number">300</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span>            <span class="token function">translate</span><span class="token punctuation">(</span>yDistance<span class="token punctuation">,</span>xDistance<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">drawImage</span><span class="token punctuation">(</span>                    image <span class="token operator">=</span> imageFore<span class="token punctuation">,</span>                    <span class="token comment">//与上面同理</span>                    dstOffset <span class="token operator">=</span> <span class="token function">IntOffset</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>y <span class="token operator">=</span> <span class="token number">480</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    dstSize <span class="token operator">=</span> <span class="token function">IntSize</span><span class="token punctuation">(</span>width <span class="token operator">=</span> imageFore<span class="token punctuation">.</span>width <span class="token operator">-</span> <span class="token number">200</span><span class="token punctuation">,</span> height <span class="token operator">=</span> imageFore<span class="token punctuation">.</span>height<span class="token punctuation">)</span>                <span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>平面绘制出来的图片如下所示（本人直男审美，可根据个人喜爱自由发挥。）</p><p><img src="/imgs/$%7BuseImgs%7D/img_10.png" alt=""></p><h2 id="陀螺仪获取角速度"><a href="#陀螺仪获取角速度" class="headerlink" title="陀螺仪获取角速度"></a>陀螺仪获取角速度</h2><p>&emsp;&emsp;Android为我们提供了一个 SensorManager 类来管理所有的传感器。故可以在主活动中获取一个 sensorManager 将其传给我们的这个组件，再在这个组件中获取陀螺仪传感器，并对其进行注册监听事件，获取翻转时的角速度和时间。</p><p>&emsp;&emsp;在主活动中获取 sensorManager：</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> sensorManager <span class="token operator">=</span> <span class="token function">getSystemService</span><span class="token punctuation">(</span>Context<span class="token punctuation">.</span>SENSOR_SERVICE<span class="token punctuation">)</span> <span class="token keyword">as</span> SensorManager<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&emsp;&emsp;将其传入组件：</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token function">ClassFree3D</span><span class="token punctuation">(</span>sensorManager <span class="token operator">=</span> sensorManager<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&emsp;&emsp;然后再组件中获取陀螺仪传感器并注册监听器，获取角速度的累积，乘以时间，获取x、y、z三个方向的角度。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> sensor <span class="token operator">=</span> sensorManager<span class="token punctuation">.</span><span class="token function">getDefaultSensor</span><span class="token punctuation">(</span>Sensor<span class="token punctuation">.</span>TYPE_GYROSCOPE<span class="token punctuation">)</span><span class="token keyword">var</span> angularX <span class="token keyword">by</span> remember <span class="token punctuation">&#123;</span> <span class="token function">mutableFloatStateOf</span><span class="token punctuation">(</span><span class="token number">0f</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token keyword">var</span> angularY <span class="token keyword">by</span> remember <span class="token punctuation">&#123;</span> <span class="token function">mutableFloatStateOf</span><span class="token punctuation">(</span><span class="token number">0f</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token keyword">var</span> angularZ <span class="token keyword">by</span> remember <span class="token punctuation">&#123;</span> <span class="token function">mutableFloatStateOf</span><span class="token punctuation">(</span><span class="token number">0f</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>sensorManager<span class="token punctuation">.</span><span class="token function">registerListener</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> SensorEventListener<span class="token punctuation">&#123;</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onSensorChanged</span><span class="token punctuation">(</span>event<span class="token operator">:</span> SensorEvent<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>timestamp <span class="token operator">!=</span> <span class="token number">0f</span> <span class="token operator">&amp;&amp;</span> event <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">val</span> dT <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>timestamp <span class="token operator">-</span> timestamp<span class="token punctuation">)</span> <span class="token operator">*</span> NS2S                angularX <span class="token operator">+=</span> event<span class="token punctuation">.</span>values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> dT                angularY <span class="token operator">+=</span> event<span class="token punctuation">.</span>values<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> dT                angularZ <span class="token operator">+=</span> event<span class="token punctuation">.</span>values<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> dT<span class="token comment">//这里将弧度制转化为角度制</span>                <span class="token keyword">var</span> angleX <span class="token operator">:</span> Float <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">toDegrees</span><span class="token punctuation">(</span>angularX<span class="token punctuation">.</span><span class="token function">toDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">var</span> angleY <span class="token operator">:</span> Float <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">toDegrees</span><span class="token punctuation">(</span>angularY<span class="token punctuation">.</span><span class="token function">toDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">var</span> angleZ <span class="token operator">:</span> Float <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">toDegrees</span><span class="token punctuation">(</span>angularZ<span class="token punctuation">.</span><span class="token function">toDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            timestamp <span class="token operator">=</span> event<span class="token operator">?</span><span class="token punctuation">.</span>timestamp<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">toFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?:</span> <span class="token number">0f</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onAccuracyChanged</span><span class="token punctuation">(</span>sensor<span class="token operator">:</span> Sensor<span class="token operator">?</span><span class="token punctuation">,</span> accuracy<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>sensor<span class="token punctuation">,</span>SensorManager<span class="token punctuation">.</span>SENSOR_STATUS_ACCURACY_LOW<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="进行运算"><a href="#进行运算" class="headerlink" title="进行运算"></a>进行运算</h2><p>&emsp;&emsp;然后由上面的公式进行运算，通过角度获得平移距离，同时也设置了最大的角度，这样就有最大的平移距离，这样可以防止平移距离过大而导致屏幕背景暴露。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">if</span> <span class="token punctuation">(</span>angleY <span class="token operator">></span> maxAngle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        angleY <span class="token operator">=</span> maxAngle    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>angleY <span class="token operator">&lt;</span> <span class="token operator">-</span>maxAngle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        angleY <span class="token operator">=</span> <span class="token operator">-</span>maxAngle    <span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>angleX <span class="token operator">></span> maxAngle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        angleX <span class="token operator">=</span> maxAngle    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>angleX <span class="token operator">&lt;</span> <span class="token operator">-</span>maxAngle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        angleX <span class="token operator">=</span> <span class="token operator">-</span>maxAngle    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> xRadio <span class="token operator">:</span> Float <span class="token operator">=</span> <span class="token punctuation">(</span>angleX <span class="token operator">/</span> maxAngle<span class="token punctuation">)</span>    <span class="token keyword">val</span> yRadio <span class="token operator">:</span> Float <span class="token operator">=</span> <span class="token punctuation">(</span>angleY <span class="token operator">/</span> maxAngle<span class="token punctuation">)</span>    xDistance <span class="token operator">=</span> xRadio <span class="token operator">*</span> maxOffset    yDistance <span class="token operator">=</span> yRadio <span class="token operator">*</span> maxOffset<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;这样就在手机每次翻转的时候都会获取新的角度，从而改变平移距离，这样图片就可以随时发生平移，实现了仿裸眼3D的功能。</p><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p>&emsp;&emsp;这里直接展示</p><center><img src="/imgs/$%7BuseImgs%7D/gif_4.gif" width = "" height = ""></center><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;说实话，实现之后自己都觉得很好看，同时也知道了如何去操作陀螺仪传感器，这也可以去实现许多交互上的创意。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Compose </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android]Jetpack Compose 实现Banner轮播图</title>
      <link href="/2023/11/20/%5BAndroid%5DJetpack%20Compose%20%E5%AE%9E%E7%8E%B0Banner%E8%BD%AE%E6%92%AD%E5%9B%BE/"/>
      <url>/2023/11/20/%5BAndroid%5DJetpack%20Compose%20%E5%AE%9E%E7%8E%B0Banner%E8%BD%AE%E6%92%AD%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;Jetpack Compose 是推荐用于构建原生 Android 界面的新工具包。它可简化并加快 Android 上的界面开发，使用更少的代码、强大的工具和直观的 Kotlin API，快速打造生动而精彩的应用。</p><p>&emsp;&emsp;本次就使用 Jetpack Compose里面的分页器（pager）来实现一个常用控件——轮播图（Banner）。这里需要对Android Compose有一定的了解，可以先去学习一下Compose的基本知识，这里放上官方直达：<a href="https://developer.android.google.cn/jetpack/compose?hl=zh-cn">直达官方Compose</a> 。</p><p>&emsp;&emsp;同时这里也放上分页器的官方文档，可以了解更多高级功能，直达：<a href="https://developer.android.google.cn/jetpack/compose/layouts/pager?hl=zh-cn#custom-page">官方分页器文档</a>。</p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>&emsp;&emsp;首先需要分析一下实现轮播图的功能。</p><p>&emsp;&emsp;轮播图需要一直循环滑动播放，所以首先就是需要一个具有单页水平滑动效果的控件。在2023年3月底，Google 正式发布Jetpack Compose 的 1.4 版本，在这次的更新中，新增了 pager 等控件，它实现了View中ViewPager类似的功能。因此，水平分页器—— HorizontalPager 可以完美起这个重任。</p><p>&emsp;&emsp;可以分析一下HorizontalPager的源码</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Composable</span><span class="token annotation builtin">@ExperimentalFoundationApi</span><span class="token keyword">fun</span> <span class="token function">HorizontalPager</span><span class="token punctuation">(</span>    state<span class="token operator">:</span> PagerState<span class="token punctuation">,</span>    modifier<span class="token operator">:</span> Modifier <span class="token operator">=</span> Modifier<span class="token punctuation">,</span>    contentPadding<span class="token operator">:</span> PaddingValues <span class="token operator">=</span> <span class="token function">PaddingValues</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span><span class="token punctuation">,</span>    pageSize<span class="token operator">:</span> PageSize <span class="token operator">=</span> PageSize<span class="token punctuation">.</span>Fill<span class="token punctuation">,</span>    beyondBoundsPageCount<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    pageSpacing<span class="token operator">:</span> Dp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">.</span>dp<span class="token punctuation">,</span>    verticalAlignment<span class="token operator">:</span> Alignment<span class="token punctuation">.</span>Vertical <span class="token operator">=</span> Alignment<span class="token punctuation">.</span>CenterVertically<span class="token punctuation">,</span>    flingBehavior<span class="token operator">:</span> SnapFlingBehavior <span class="token operator">=</span> PagerDefaults<span class="token punctuation">.</span><span class="token function">flingBehavior</span><span class="token punctuation">(</span>state <span class="token operator">=</span> state<span class="token punctuation">)</span><span class="token punctuation">,</span>    userScrollEnabled<span class="token operator">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    reverseLayout<span class="token operator">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    key<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>index<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">-></span> Any<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span>    pageNestedScrollConnection<span class="token operator">:</span> NestedScrollConnection <span class="token operator">=</span>     PagerDefaults<span class="token punctuation">.</span><span class="token function">pageNestedScrollConnection</span><span class="token punctuation">(</span>        Orientation<span class="token punctuation">.</span>Horizontal    <span class="token punctuation">)</span><span class="token punctuation">,</span>    pageContent<span class="token operator">:</span> <span class="token annotation builtin">@Composable</span> PagerScope<span class="token punctuation">.</span><span class="token punctuation">(</span>page<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;其中最重要的当然是PagerState，顾名思义，这个就是用来管理HorizontalPager内pager状态的。这里是HorizontalPager的简单使用。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"> <span class="token comment">// 显示 10 个项目</span> <span class="token function">HorizontalPager</span><span class="token punctuation">(</span>pageCount <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> page <span class="token operator">-></span>     <span class="token comment">// 每一页的内容，比如显示个文本</span>     <span class="token function">Text</span><span class="token punctuation">(</span>         text <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Page: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">page</span></span><span class="token string">"</span></span><span class="token punctuation">,</span>         modifier <span class="token operator">=</span> Modifier<span class="token punctuation">.</span><span class="token function">fillMaxWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;然后就是在人没有对其进行滑动的时候，需要轮播图进行自动循环，并具有延迟展示图片内容。PagerState提供了方法可以获得当前Pager是否处于拖动状态。所以可以先使用这个方法获得当前状态，然后进行判断。延迟则可以使用delay函数来实现。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> isDragged <span class="token keyword">by</span> pagerState<span class="token punctuation">.</span>interactionSource<span class="token punctuation">.</span><span class="token function">collectIsDraggedAsState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&emsp;&emsp;最后还需要一个指示器，也可以使用 Box 或者 Canvas 简单实现，方法众多，可以尽情发挥。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>&emsp;&emsp;通过上面的分析，可以来实现轮播图Banner了，现在将实现分为三步。</p><h2 id="水平分页器"><a href="#水平分页器" class="headerlink" title="水平分页器"></a>水平分页器</h2><p>&emsp;&emsp;首先需要定义好Pager的数量——pagerCount。这里我定义了一个List用来存储图片的URL，之后也是使用了coil库来加载图片。因此，这里的 pagerCount 就等于 images.size。</p><p>&emsp;&emsp;接着就是定义 HorizontalPager 的 pagerState，直接使用 rememberPagerState，然后将 pagerCount 传入。</p><p>&emsp;&emsp;然后就可以使用HorizontalPager了，这里也设置了一下pageSpacing 来分隔此分页器中页面的空间量。同时写了个 BannerCard 来修饰一下图片，传入图片URL，然后使用 coil 的 AsyncImage 来加载图片。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token annotation builtin">@OptIn</span><span class="token punctuation">(</span>ExperimentalFoundationApi<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation builtin">@Composable</span><span class="token keyword">fun</span> <span class="token function">Banner</span><span class="token punctuation">(</span>    images<span class="token operator">:</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span>    autoScrollDuration<span class="token operator">:</span> Long <span class="token operator">=</span> <span class="token number">1500L</span>   <span class="token comment">//延迟的时间，可以自行设置，后面要用到。</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> pagerCount <span class="token operator">=</span> images<span class="token punctuation">.</span>size    <span class="token keyword">val</span> pagerState <span class="token operator">=</span> rememberPagerState<span class="token punctuation">&#123;</span>        pagerCount    <span class="token punctuation">&#125;</span>    Box <span class="token punctuation">&#123;</span>        <span class="token function">HorizontalPager</span><span class="token punctuation">(</span>            state <span class="token operator">=</span> pagerState<span class="token punctuation">,</span>            contentPadding <span class="token operator">=</span> <span class="token function">PaddingValues</span><span class="token punctuation">(</span>horizontal <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span><span class="token punctuation">,</span>            pageSpacing <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">.</span>dp        <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>index <span class="token operator">-></span>            <span class="token function">BannerCard</span><span class="token punctuation">(</span>                imageURL <span class="token operator">=</span> images<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span>                modifier <span class="token operator">=</span> Modifier                    <span class="token punctuation">.</span><span class="token function">padding</span><span class="token punctuation">(</span>top <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span>            <span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation builtin">@Composable</span><span class="token keyword">fun</span> <span class="token function">BannerCard</span><span class="token punctuation">(</span>    imageURL <span class="token operator">:</span> String<span class="token punctuation">,</span>    modifier <span class="token operator">:</span> Modifier<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">Card</span> <span class="token punctuation">(</span>modifier <span class="token operator">=</span> modifier<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">AsyncImage</span><span class="token punctuation">(</span>model <span class="token operator">=</span> imageURL<span class="token punctuation">,</span> contentDescription <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;实现效果如下</p><center><img src="/imgs/$%7BuseImgs%7D/gif_1.gif" width = "" height = ""></center><h2 id="自动循环与延迟"><a href="#自动循环与延迟" class="headerlink" title="自动循环与延迟"></a>自动循环与延迟</h2><p>&emsp;&emsp;首先先定义一个布尔类型的 isDragged 来获取是否处于拖动状态，然后对其进行判断，当没有人为拖动时，使用kotlin中的with 函数，在里面设立一个局部变量来储存当前页数的值，然后将其作为 LaunchedEffect （协程是Android kotlin开发中一个重要知识，在Compose中采用附带效应 effect 来实现协程开发）的参数，在协程使用 pagerState 的函数 animateScrollToPage 来实现自动滑动，nextPage 通过当前页数 + 1然后再对总页数取模来实现循环。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> isDragged <span class="token keyword">by</span> pagerState<span class="token punctuation">.</span>interactionSource<span class="token punctuation">.</span><span class="token function">collectIsDraggedAsState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>isDragged<span class="token punctuation">.</span><span class="token function">not</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">with</span><span class="token punctuation">(</span>pagerState<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">var</span> currentPageKey <span class="token keyword">by</span> remember <span class="token punctuation">&#123;</span> <span class="token function">mutableIntStateOf</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>            <span class="token function">LaunchedEffect</span><span class="token punctuation">(</span>key1 <span class="token operator">=</span> currentPageKey<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                launch <span class="token punctuation">&#123;</span>                    <span class="token function">delay</span><span class="token punctuation">(</span>timeMillis <span class="token operator">=</span> autoScrollDuration<span class="token punctuation">)</span>                    <span class="token keyword">val</span> nextPage <span class="token operator">=</span> <span class="token punctuation">(</span>currentPage <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mod</span><span class="token punctuation">(</span>pageCount<span class="token punctuation">)</span>                    <span class="token function">animateScrollToPage</span><span class="token punctuation">(</span>page <span class="token operator">=</span> nextPage<span class="token punctuation">)</span>                    currentPageKey <span class="token operator">=</span> nextPage                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;将其加入后再次启动（虚拟机！启动！！！）如下，发现已经可以自己循环播放了。</p><center><img src="/imgs/$%7BuseImgs%7D/gif_2.gif" width = "" height = ""></center><h2 id="添加指示器"><a href="#添加指示器" class="headerlink" title="添加指示器"></a>添加指示器</h2><p>&emsp;&emsp;添加指示器，本蒟蒻采用的是 Canvas 来实现。首先在一行中使用 repeat 函数进行重复，有多少张图就 repeat 多少次，即repeat（pageCount）,然后定义颜色，与当前页数相同的指示点颜色与其他点颜色进行区别，既然要画点，所以使用 Canvas 中的 drawCircle 来进行绘画，可以自行定义大小。</p><p>&emsp;&emsp;因为要使用pagerState来获得当前页数，所以指示器需要传入pagerState，和pagerCount。同时需要通过 modifier 修饰符将指示器放在父 Box 容器的底部，这样指示器就可以显示在图片的上方，并处于底部。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token annotation builtin">@OptIn</span><span class="token punctuation">(</span>ExperimentalFoundationApi<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation builtin">@Composable</span><span class="token keyword">fun</span> <span class="token function">DotIndicators</span><span class="token punctuation">(</span>    pageCount <span class="token operator">:</span> Int<span class="token punctuation">,</span>    pagerState <span class="token operator">:</span> PagerState<span class="token punctuation">,</span>    modifier<span class="token operator">:</span> Modifier<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">Row</span> <span class="token punctuation">(</span>        modifier <span class="token operator">=</span> modifier<span class="token punctuation">.</span><span class="token function">padding</span><span class="token punctuation">(</span>bottom <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span><span class="token punctuation">,</span>        horizontalArrangement <span class="token operator">=</span> Arrangement<span class="token punctuation">.</span>Center<span class="token punctuation">,</span>        verticalAlignment <span class="token operator">=</span> Alignment<span class="token punctuation">.</span>Bottom    <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">repeat</span><span class="token punctuation">(</span>pageCount<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>iteration <span class="token operator">-></span>            <span class="token keyword">val</span> color <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pagerState<span class="token punctuation">.</span>currentPage <span class="token operator">==</span> iteration<span class="token punctuation">)</span> MaterialTheme<span class="token punctuation">.</span>colorScheme<span class="token punctuation">.</span>surface                           <span class="token keyword">else</span> MaterialTheme<span class="token punctuation">.</span>colorScheme<span class="token punctuation">.</span>onSurface            <span class="token function">Canvas</span><span class="token punctuation">(</span>                modifier <span class="token operator">=</span> Modifier                <span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">padding</span><span class="token punctuation">(</span>horizontal <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span><span class="token punctuation">,</span> onDraw <span class="token operator">=</span> <span class="token punctuation">&#123;</span>                <span class="token function">drawCircle</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;最后再次启动！</p><center><img src="/imgs/$%7BuseImgs%7D/gif_3.gif" width = "" height = ""></center><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;如此如此，这般这般，就实现了轮播图的效果，如果任觉得不满于此，也可以跟随自己的想法去将其变得更加 niu pi。同时也可以多多探索。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Compose </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[深入理解计算机系统]CSAPP DataLab 学习记录</title>
      <link href="/2023/10/11/%5B%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%5DCSAPP%20DataLab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/10/11/%5B%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%5DCSAPP%20DataLab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p>&emsp;&emsp;最近在看完《深入理解计算机系统》前两章之后，也将其第一个Lab——DataLab完成了，于是来对此做一个记录。DataLab主要是对整型和浮点型的实验，其中对条件语句、算数运算还有逻辑运算进行了不同的限制。</p><h1 id="实验环境的搭建："><a href="#实验环境的搭建：" class="headerlink" title="实验环境的搭建："></a>实验环境的搭建：</h1><p>&emsp;&emsp;首先由于其实验环境是unix，我使用的是VMware Workstation + Ubuntu来搭建实验环境。VMware虚拟机和Ubuntu的安装可以看这篇博客<a href="https://blog.csdn.net/qq_41782425/article/details/85119258">VMware Ubuntu安装详细过程（详细图解）_vmware安装ubuntu-CSDN博客</a>，具体搭建过程可看这篇博客：<a href="https://blog.csdn.net/qq_39876147/article/details/124481740">【CSAPP】Lab0 - 环境配置_csapp 3e操作环境搭建_Luqwera的博客-CSDN博客</a>。</p><p>&emsp;&emsp;如果不想安装虚拟机，也可以使用Docker里的Linux容器来搭建，具体的操作过程可看这篇博客<a href="https://blog.csdn.net/qq_39029579/article/details/112169980">超详解 CS:APP:Lab1-DataLab_optional cmd line args-CSDN博客</a>。</p><p>&emsp;&emsp;完成环境的搭建后便可以开始做DataLab了。</p><h1 id="问题描述及解析："><a href="#问题描述及解析：" class="headerlink" title="问题描述及解析："></a>问题描述及解析：</h1><h2 id="1-bitXor"><a href="#1-bitXor" class="headerlink" title="1.bitXor"></a>1.bitXor</h2><p>&emsp;&emsp;题目的意思就是只使用 ~（取反符号） 和 &amp; （与运算符）来实现 ^ (异或)。</p><p>&emsp;&emsp;看到这个，首先想到了数字逻辑里的一个公式：</p><p><img src="/imgs/$%7BuseImgs%7D/img_1.png" alt=""></p><p>&emsp;&emsp;就是 “同或的非” = “异或”，但是里面有“或”运算符，所以要再使用一下德摩根定律：</p><p>​                                                                            <img src="/imgs/$%7BuseImgs%7D/img_2.png" alt=""></p><p>&emsp;&emsp;就可以解决这道题了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * bitXor - x^y using only ~ and &amp;  *   Example: bitXor(4, 5) = 1 *   Legal ops: ~ &amp; *   Max ops: 14 *   Rating: 1 */</span><span class="token keyword">int</span> <span class="token function">bitXor</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">~</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">~</span>x <span class="token operator">&amp;</span> <span class="token operator">~</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-tmin"><a href="#2-tmin" class="headerlink" title="2.tmin"></a>2.tmin</h2><p>&emsp;&emsp;题目的意思就是返回对32位 int 最小的二补数（就是补码）。下面是 n 比特的二补数系统中几个特别的数字：</p><div class="table-container"><table><thead><tr><th style="text-align:center">二补数</th><th style="text-align:center">实际数字</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">0111 1111 …. 1111</td><td style="text-align:center">$2^{n-1} -1$</td><td style="text-align:center">最大正数</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">0000 0000 …. 0001</td><td style="text-align:center">1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">0000 0000 …. 0000</td><td style="text-align:center">0</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">1111 1111 …. 1111</td><td style="text-align:center">-1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">1000 0000 …. 0000</td><td style="text-align:center">$-2^{n-1}$</td><td style="text-align:center">最小负数</td></tr></tbody></table></div><p>&emsp;&emsp;所以在32位的环境下，补码的最小值就是：Tmin = $-2^{32-1}$$=-2^{31}$。用十六进制表示就是0x80000000，及将 1 向左移 31位。这样就可以解决了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * tmin - return minimum two's complement integer  *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 4 *   Rating: 1 */</span><span class="token keyword">int</span> <span class="token function">tmin</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">31</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-isTmax"><a href="#3-isTmax" class="headerlink" title="3.isTmax"></a>3.isTmax</h2><p>&emsp;&emsp;这道题目需要你对输入的 x 进行判断是否为最大的补码，如果是就返回 1 ，不是则返回 0 。</p><p>&emsp;&emsp;由上一题可以知道，在32位的环境中最大的补码为 $2^{31}-1$ 及 0111 1111 …. 1111，所以我们可以从这个最大数入手。</p><p>&emsp;&emsp;首先可以发现 Tmax = 0111 1111 …. 1111 在加上一个 1 后会直接溢出变成 1000 0000 …. 0000，然后再对其取反后，就又变回了原来的 Tmax，故可以得到~(Tmax+1)= Tmax，因此，我们现在只需要判断~(x+1)与 x 是否相等就可以得出结论。但是题目限制无法使用等号，所以就可以利用异或运算的一个特性，即 x⊕x=0 ，就是两个相同的数进行异或后结果为 0 ，这里需要相同情况下返回 1，故要使用 ! 符号。所以最后组合在一起就是:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">^</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&emsp;&emsp;但是当你保存检测后发现没有通过。</p><p><img src="/imgs/$%7BuseImgs%7D/img_3.png" alt=""></p><p>&emsp;&emsp;仔细看了错误后会发现当 x = -1 时，返回的是 1 ，但应该是 0。这是因为在补码中 -1 = 1111 1111 …. 1111，-1+1 = 1 0000 0000 …. 0000 ，由于超过了32位的比特位，所以会被截断，高位进位无效，此时等于 0000 0000 …. 0000，即为0，而且正好每一位都与 -1的每一位互补。故需要我们来对 -1 进行特判。可以在 x+1 后对其进行 !! 操作来区别最大值和 -1 。</p><p>&emsp;&emsp;故最终解决方法如下。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* * isTmax - returns 1 if x is the maximum, two's complement number, *     and 0 otherwise  *   Legal ops: ! ~ &amp; ^ | + *   Max ops: 10 *   Rating: 1 */</span><span class="token keyword">int</span> <span class="token function">isTmax</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">^</span>x<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-allOddBits"><a href="#4-allOddBits" class="headerlink" title="4.allOddBits"></a>4.allOddBits</h2><p>&emsp;&emsp;该题的意思和上题差不多，就是判断 x 补码的奇数位是否全为 1，如果是就返回1，不是则返回0。并且告知了你32位是从第0位到第31位，所以不要判断错了。</p><p>&emsp;&emsp;读懂题意，就能想到用奇数位上全是1，偶数位上全为0的数，即0xAAAAAAAA与 x 进行与运算（&amp;），再看其结果是否任然等于0xAAAAAAAA，若相等，则 x 符合条件，返回1，不等则返回0。同样这一题与上一题一样，无法使用等号，所以继续使用异或来判断。但是需要注意本实验有一个要求</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*Integer constants 0 through 255 (0xFF), inclusive. You are      not allowed to use big constants such as 0xffffffff.*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;故无法直接定义 0xAAAAAAAA这么大的数，所以需要先得到0xAAAAAAAA。可以考虑用0xAA，通过移位和运算获得。之后就迎刃而解了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * allOddBits - return 1 if all odd-numbered bits in word set to 1 *   where bits are numbered from 0 (least significant) to 31 (most significant) *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 12 *   Rating: 2 */</span><span class="token keyword">int</span> <span class="token function">allOddBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0xAA</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> temp <span class="token operator">+</span> <span class="token punctuation">(</span>temp<span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token punctuation">(</span>a<span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token operator">^</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-negate"><a href="#5-negate" class="headerlink" title="5.negate"></a>5.negate</h2><p>&emsp;&emsp;这一题就是求 x 的相反数，一个很基础的结论就是~x + x = -1，调整一下就是 -x = ~x+1（牢记），补码的常见操作。</p><p>于是这题就解决了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * negate - return -x  *   Example: negate(1) = -1. *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 5 *   Rating: 2 */</span><span class="token keyword">int</span> <span class="token function">negate</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">~</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-isAsciiDigit"><a href="#6-isAsciiDigit" class="headerlink" title="6.isAsciiDigit"></a>6.isAsciiDigit</h2><p>&emsp;&emsp;该题就是来判断 x 是否在 0x30 到 0x39 之间，如果是则返回 1。</p><p>&emsp;&emsp;思路就是先通过右移来判断除了后4位外，其余的位是否与0x3相同，将其作为第一个条件，然后来判断后四位是否在0到9之间。</p><p>&emsp;&emsp;第一个条件可以通过将 x 右移4位后与0x3进行异或来判断是否相同，第二条件就将 x 和0xF进行与运算这样就可以获得后四位所表示的数了，在将其减去10，即0xA，最后只用判断减去10后的结果的符号。由于无法使用减法，所以这里使用上一题的结论，加上-10就行，（-10 = ~10+1）。</p><p>&emsp;&emsp;最后可以通过右移31位获得结果的符号，若为负，则为-1，若为正，则为0，又因为任何一个数与-1进行与运算都会等于自己，所以第一个条件与第二个条件均成立时才会返回 1。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9') *   Example: isAsciiDigit(0x35) = 1. *            isAsciiDigit(0x3a) = 0. *            isAsciiDigit(0x05) = 0. *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 15 *   Rating: 3 */</span><span class="token keyword">int</span> <span class="token function">isAsciiDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">0x3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token operator">~</span><span class="token number">0xA</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> a <span class="token operator">&amp;</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-conditional"><a href="#7-conditional" class="headerlink" title="7.conditional"></a>7.conditional</h2><p>&emsp;&emsp;这一题就是使用允许的运算操作符：!  ~  &amp;  ^  |  +  &lt;&lt;  &gt;&gt;，来实现三目运算符，即当 x 为真时（x ≠ 0）返回 y ，为假时（x = 0），返回 z 。</p><p>&emsp;&emsp;首先可以先判断 x 为真为假，对 x 使用两次 ! 运算，若 x 为真，则此时为 1，反之，此时为 0。接着可以想到题目不是返回 y 就是返回 z ，所以可以想到使用或运算（|），现在需要我们在 x 为真时，将包含 z 的那一部分变为0，包含 y 的那一部分变为 y ，反之同理。然后可以想到任何一个数与 0 进行与运算都等于 0  ，任何一个数与 -1 进行与运算都等于自己本身。并且 ~0 = -1，~(-1) = 0，对于0 和 -1 都是 x 为假为真时进行取反操作可以得到的，故可以列出下表</p><div class="table-container"><table><thead><tr><th style="text-align:center">x</th><th style="text-align:center">a=!!x</th><th style="text-align:center">b=~a+1</th><th style="text-align:center">b&amp;y</th><th style="text-align:center">~b&amp;z</th><th style="text-align:center">（b&amp;y)$\vert$(~b&amp;z)</th></tr></thead><tbody><tr><td style="text-align:center">真</td><td style="text-align:center">1</td><td style="text-align:center">-1</td><td style="text-align:center">y</td><td style="text-align:center">0</td><td style="text-align:center">y</td></tr><tr><td style="text-align:center">假</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">z</td><td style="text-align:center">z</td></tr></tbody></table></div><p>&emsp;&emsp;可以发现完全符合题目所需，故解决方法如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * conditional - same as x ? y : z  *   Example: conditional(2,4,5) = 4 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 16 *   Rating: 3 */</span><span class="token keyword">int</span> <span class="token function">conditional</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>x<span class="token punctuation">;</span>  <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token operator">~</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>b <span class="token operator">&amp;</span> y<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token operator">~</span>b <span class="token operator">&amp;</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-isLessOrEqual"><a href="#8-isLessOrEqual" class="headerlink" title="8.isLessOrEqual"></a>8.isLessOrEqual</h2><p>&emsp;&emsp;通过题目的描述，需要我们来判断 x 与 y 的大小，如果 x &lt;= y 时返回1，否则返回0。</p><p>&emsp;&emsp;首先可以很快想到如果 x 是个负数， y 是个正数，那么 x 一定小于 y，则一定返回1，相反，当  x 为正，y为负，则一定返回0。所以可以先判断符号，通过右移31来获取符号位，但由于负数一般采用的是算术右移，所以最后都需要与1进行与运算，得到符号位。</p><p>&emsp;&emsp;接着使用异或来判断是否符号相同，若相同，则需要用 x 减去 y，即加上-y ，再来判断相减之后的符号位，但同时要注意到当x = y时，相减之后符号位为 0 ，与 x &lt; y时相减后情况不同，所以在此用了另一种方法，x &lt;= y等同于 x &lt; y+1，于是最后变为 x - y -1&lt; 0，同时 -y = ~y +1，所以最后求的就是 x + ~y 的符号了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * isLessOrEqual - if x &lt;= y  then return 1, else return 0  *   Example: isLessOrEqual(4,5) = 1. *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 24 *   Rating: 3 */</span><span class="token keyword">int</span> <span class="token function">isLessOrEqual</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">(</span>y<span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> diff <span class="token operator">=</span> a <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不同符号时,仅x为负，为y为正时，为1</span>  <span class="token keyword">int</span> same <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>  <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>same<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token operator">~</span>y<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> diff <span class="token operator">|</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-logicalNeg"><a href="#9-logicalNeg" class="headerlink" title="9.logicalNeg"></a>9.logicalNeg</h2><p>&emsp;&emsp;这里要求我们通过使用允许的运算操作符：~  &amp;  ^  |  +  &lt;&lt;  &gt;&gt;  来实现逻辑非操作（!），即对于 x ，只要 x 不为0 ，那么就返回 0，否则返回 1。</p><p>&emsp;&emsp;首先，需要知道一个不为0的数与自己的相反数进行或运算会等于一个负数，0与自己的相反数进行或运算结果还是 0 ，并且一个负数右移31位后结果为 -1 ，而 0右移31位后则还是 0，最后再加上一个1，那么就都符合题目的需求了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * logicalNeg - implement the ! operator, using all of  *              the legal operators except ! *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 *   Legal ops: ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 12 *   Rating: 4  */</span><span class="token keyword">int</span> <span class="token function">logicalNeg</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token operator">~</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">|</span>a<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-howManyBits"><a href="#10-howManyBits" class="headerlink" title="10.howManyBits"></a>10.howManyBits</h2><p>&emsp;&emsp;首先理解题意，要求求一个值使用补码来表示最少需要多少位。</p><p>通过对样例的分析可以得出结论，当 x 为正数时，在补码中位于最高位 1 之前的 0 是可以省略的，所以最少位数等于最高位 1 的位数加上 1 位符号位，而当 x 是一个负数时，同样的道理，位于最高位 0 之前的 1 也是可以省略的，所以此时最少位数等于最高位 0 的位数加上 1 位符号位，而对于 0 ，由于其补码没有符号位，所以表示只需 1 位。</p><p>&emsp;&emsp;按照上述过程，需要进行查找。为了方便统一，这里先将为负数的 x 取反，这样就和正数一样，只需找到最高位 1 后再加 1 位就行了，所以有如下操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> sign <span class="token operator">=</span> x<span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">;</span><span class="token comment">//先取符号位。</span>x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">~</span>sign<span class="token punctuation">)</span> <span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>sign <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//x为非负数则不变，x为负数则按位取反。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>&emsp;&emsp;接下来就是进行查找了，这里可以使用到二分的思想来进行查找，先看 x 最高的 16 位，将 x 进行右移 16 位，再将其规格化。</p><p>&emsp;&emsp;如果最高 16 位有 1 ，那么处理后的 x 就等于 1，故此时需要的位数至少为 16位，可以对该权值进行记录，只需要将处理后的 x 左移 4位，之后就对 <u>x 右移 16 位后的低16位</u>（注：此时的低16位就是原本 x 的高 16位）进行二分，将低 16 位中的高 8 位进行同样的操作，从而找到在 x 高16位中最高位 1。</p><p>&emsp;&emsp;如果没有 1 ，那么  x  处理后就等于 0 ，记录的值也等于 0 ，此时就不需要右移，而是在 x 的低 16 位中的高 8 位进行同样的操作。</p><p>&emsp;&emsp;综上，x 的右移操作可以总结为 x &gt;&gt; 本次记录的权值。以此类推，分别对高 8 位，4 位，2 位，1位进行同样操作。最后将所有权值进行相加，不要忘了在加一个 1 （对于非 0 数是加上 1 位的符号位，对于 0 是自己本身的 1 位。），此时就满足题目的要求了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* howManyBits - return the minimum number of bits required to represent x in *             two's complement *  Examples: howManyBits(12) = 5 *            howManyBits(298) = 10 *            howManyBits(-5) = 4 *            howManyBits(0)  = 1 *            howManyBits(-1) = 1 *            howManyBits(0x80000000) = 32 *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *  Max ops: 90 *  Rating: 4 */</span><span class="token keyword">int</span> <span class="token function">howManyBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> sign <span class="token operator">=</span> x<span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">;</span>  x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">~</span>sign<span class="token punctuation">)</span> <span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>sign <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> bit_16 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>  x <span class="token operator">=</span> x <span class="token operator">>></span> bit_16<span class="token punctuation">;</span>  <span class="token keyword">int</span> bit_8 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">;</span>  x <span class="token operator">=</span> x <span class="token operator">>></span> bit_8<span class="token punctuation">;</span>  <span class="token keyword">int</span> bit_4 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">;</span>  x <span class="token operator">=</span> x <span class="token operator">>></span> bit_4<span class="token punctuation">;</span>  <span class="token keyword">int</span> bit_2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">;</span>  x <span class="token operator">=</span> x <span class="token operator">>></span> bit_2<span class="token punctuation">;</span>  <span class="token keyword">int</span> bit_1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  x <span class="token operator">=</span> x<span class="token operator">>></span>bit_1<span class="token punctuation">;</span>  <span class="token keyword">int</span> bit_0 <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token keyword">int</span> ans <span class="token operator">=</span> bit_16<span class="token operator">+</span>bit_8<span class="token operator">+</span>bit_4<span class="token operator">+</span>bit_2<span class="token operator">+</span>bit_1<span class="token operator">+</span>bit_0<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-floatScale2"><a href="#11-floatScale2" class="headerlink" title="11.floatScale2"></a>11.floatScale2</h2><p>&emsp;&emsp;从这里开始就属于浮点数运算部分，首先得了解一下IEEE浮点表示，在IEEE浮点标准中用</p><script type="math/tex; mode=display">V=(-1)^{s} \times M\times 2^{E}</script><p>&emsp;&emsp;来表示一个数。其中 符号 s 表示正负（s=0表示正数，s=1表示负数），尾数M 是一个<strong>二进制小数</strong>，阶码 E 是对浮点数的加权，权重为 2 的 E 次幂（可能为负数）。因此将浮点数的位表示划分为三个部分。<img src="/imgs/$%7BuseImgs%7D/img_4.png" alt=""></p><p>&emsp;&emsp;一个单独的符号位 s 直接编码符号 s 。（此 s 非彼 s）</p><p>&emsp;&emsp;k 位的阶码字段exp 来编码阶码 E。</p><p>&emsp;&emsp;n 位小数字段 frac 编码位数 M ，但是编码出来的值也依赖阶码字段的值是否等于 0 。</p><p>&emsp;&emsp;根据 exp 的值，被编码的值可以分成三种情况，最后一种情况有两个变种。<img src="/imgs/$%7BuseImgs%7D/img_5.png" alt=""></p><p>&emsp;&emsp;其中小数字段 frac 被解释为描述小数值 f ，0 ≤ f &lt;1 ，用二进制表示为</p><script type="math/tex; mode=display">f = 0.f_{n-1}...f_{1}f_{0}</script><p>&emsp;&emsp;当 exp 的位模式既不全为 0，又不全为 1 时，则属于规格化的值，总结如下</p><script type="math/tex; mode=display">Bias=2^{k-1}-1</script><script type="math/tex; mode=display">E=e-Bias</script><script type="math/tex; mode=display">M=1+f</script><p>&emsp;&emsp;当 exp 全为 0 时，则属于非规格的值，总结如下</p><script type="math/tex; mode=display">Bias=2^{k-1}-1</script><script type="math/tex; mode=display">E=1-Bias</script><script type="math/tex; mode=display">M=f</script><p>&emsp;&emsp;当 exp 全为 1 时，属于特殊值，其中当小数域全为 0 时，表示的是无穷（∞），按照 s 的正负分为 +∞ 与 -∞ ；当小数域不为 0 时，结果被称为“NaN”，即不是一个数。 </p><p>&emsp;&emsp;现在可以来看这一题了，题目需要我们求出浮点数* 2 之后的值。</p><p>&emsp;&emsp;首先依据IEEE浮点数分别求出单精度浮点数的符号位、阶码位以及小数位。由上面可知 float 是32位，一般 s 为 1 位，exp 为 8 位，frac 为 23 位。可以通过位运算来获得，如下</p><pre class="line-numbers language-none"><code class="language-none">unsigned s &#x3D; (uf&gt;&gt;31)&amp;1;unsigned e &#x3D; (uf &amp; 0x7f800000)&gt;&gt;23;unsigned f &#x3D; (uf &amp; 0x7fffff);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;然后根据上面的三种情况进行分析，即规格化的值、非规格化的值以及特殊值。其中，当为特殊值时，两种情况都是可以直接返回的。当为非规格化的值时，那么值就为 0 或无穷小，直接<em> 2返回就行，f 此时就是尾码，所以就直接 f &lt;&lt;= 1。当为规格化的值时， 由IEEE浮点表达式可知，只需要将exp+1，那么E也会 + 1，最终就会实现</em>2的效果。</p><p>&emsp;&emsp;所以最终解决方法如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * floatScale2 - Return bit-level equivalent of expression 2*f for *   floating point argument f. *   Both the argument and result are passed as unsigned int's, but *   they are to be interpreted as the bit-level representation of *   single-precision floating point values. *   When argument is NaN, return argument *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while *   Max ops: 30 *   Rating: 4 */</span><span class="token keyword">unsigned</span> <span class="token function">floatScale2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">unsigned</span> s <span class="token operator">=</span> <span class="token punctuation">(</span>uf<span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> e <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">&amp;</span> <span class="token number">0x7f800000</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">23</span><span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> f <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">&amp;</span> <span class="token number">0x7fffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> ans<span class="token punctuation">;</span>  <span class="token comment">//特殊值，直接返回</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> uf<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//非规格化</span>      f <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>      ans <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token operator">&lt;&lt;</span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>e<span class="token operator">&lt;&lt;</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token operator">|</span>f<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token comment">//规格化</span>      e<span class="token operator">++</span><span class="token punctuation">;</span>      ans <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token operator">&lt;&lt;</span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>e<span class="token operator">&lt;&lt;</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token operator">|</span>f<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-floatFloat2Int"><a href="#12-floatFloat2Int" class="headerlink" title="12.floatFloat2Int"></a>12.floatFloat2Int</h2><p>&emsp;&emsp;这个函数让我们把一个给定的浮点数 uf 转换为 int 类型。因为 int 类型的范围相较于 float 小，所以会出现精度损失的情况。</p><p>首先还是和上一题一样，求出符号位 s ，阶吗 exp ，尾数 frac。再计算一下真实的阶数 E = exp - 127。如果 E &gt;=31 时，即为特殊值时，按照题目的要求返回 0x80000000u。 如果 E &lt; 0 时，即为非规格化的值时，此时 0&lt;= f &lt; 1，直接返回 0 。最后对于规格化的值，就按照正常处理，即</p><script type="math/tex; mode=display">V=(-1)^{s} \times M\times 2^{E}</script><p>&emsp;&emsp;先算出真实的尾数 M = frac | (1 &lt;&lt; 23)，同时 frac为23位，所以如果 E &gt;= 23则进行加权时，则要在frac的末尾加上（E - 23）个 0，若 E &lt; 23，则frac 末尾的（23-E）个数就无法保留，通过位运算可以实现。</p><p>&emsp;&emsp;同时还有一点需要注意，就是输入的数可能为负数，所以最后还需根据 s 的值进行判断。</p><p>&emsp;&emsp;最终代码如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * floatFloat2Int - Return bit-level equivalent of expression (int) f *   for floating point argument f. *   Argument is passed as unsigned int, but *   it is to be interpreted as the bit-level representation of a *   single-precision floating point value. *   Anything out of range (including NaN and infinity) should return *   0x80000000u. *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while *   Max ops: 30 *   Rating: 4 */</span><span class="token keyword">int</span> <span class="token function">floatFloat2Int</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//同样先获得符号s，尾数f，阶码e</span>  <span class="token keyword">unsigned</span> s <span class="token operator">=</span> <span class="token punctuation">(</span>uf<span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0x1</span><span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> e <span class="token operator">=</span> <span class="token punctuation">(</span>uf<span class="token operator">>></span><span class="token number">23</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xff</span><span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> f <span class="token operator">=</span> uf <span class="token operator">&amp;</span> <span class="token number">0x7fffff</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> E <span class="token operator">=</span> e <span class="token operator">-</span> <span class="token number">127</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>E<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>E <span class="token operator">>=</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0x80000000u</span><span class="token punctuation">;</span>  <span class="token keyword">else</span><span class="token punctuation">&#123;</span>      f <span class="token operator">=</span> f <span class="token operator">|</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">23</span><span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>E<span class="token operator">&lt;</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           f <span class="token operator">>>=</span> <span class="token punctuation">(</span><span class="token number">23</span><span class="token operator">-</span>E<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>           f <span class="token operator">&lt;&lt;=</span> <span class="token punctuation">(</span>E<span class="token operator">-</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">-</span>f<span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">return</span> f<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="13-floatPower2"><a href="#13-floatPower2" class="headerlink" title="13.floatPower2"></a>13.floatPower2</h2><p>&emsp;&emsp;这一题要求计算浮点数2.0^x。因为在浮点数中阶码表示的意义正好就是2的多少次幂，所以我们想到对阶码出手。</p><p>&emsp;&emsp;但是需要先导出浮点数规格化和非规格化分别表示的浮点数的范围。</p><p>&emsp;&emsp;对于非规格化的 E = 1-Bias = 1- 127 = -126，而M的最小值则为0.000…1，等于 $2^{-23}$，所以非规格化浮点的最小值为 2 的 -149 次方，M的最大值则等于 $1-2^{-23}$，所以非规格化的浮点最大为 $2^{-126}\times(1-2^{-23})$。</p><p>&emsp;&emsp;对于规格化的浮点，M的最小值为 1 ，E 的最小值为 1- 127 = -126，所以最小为 $2^{-126}$ 。M 的最大值为 1.111…11，E 的最大值为 127，故规格化的浮点最大值不到 $2^{128}$。</p><p>&emsp;&emsp;就可以得到下表</p><div class="table-container"><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th></tr></thead><tbody><tr><td style="text-align:center">规格化</td><td style="text-align:center">$2^{-126}$</td><td style="text-align:center">$2^{127}\times(2-2^{-23})$</td></tr><tr><td style="text-align:center">非规格化</td><td style="text-align:center">$2^{-149}$</td><td style="text-align:center">$2^{-126}\times(1-2^{-23})$</td></tr></tbody></table></div><p>&emsp;&emsp;所以</p><ol><li><p>x &gt; 127时，返回NaN 。</p></li><li><p>x &lt;= -149时，返回 0。</p></li><li><p>-126 &lt;= x &lt;= 127时，为规格化的，就直接让尾码全为0，控制阶码就可以了，由 x = expr - bias 可得 exp = x+ 127 。</p></li><li><p>-149  &lt; x &lt; -126时，为非规格化的，阶码值 E = 1 - bias = -126。这个时候只能通过控制尾码来计算。由 </p><script type="math/tex; mode=display">M\times2^{-126}=2^{x}</script><p>可以推断出 $M=2^{x+126}$ 。尾码的值是二次幂的形式，所以可以通过一个“1”左移获得，就可以设 1 左移了 n 位，则 $x+126 = -(23-n)$，等到n = x+ 149。</p><p>故最终解决方法如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*       * floatPower2 - Return bit-level equivalent of the expression 2.0^x      *   (2.0 raised to the power x) for any 32-bit integer x.      *      *   The unsigned value that is returned should have the identical bit      *   representation as the single-precision floating-point number 2.0^x.      *   If the result is too small to be represented as a denorm, return      *   0. If too large, return +INF.      *       *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while       *   Max ops: 30       *   Rating: 4      */</span>     <span class="token keyword">unsigned</span> <span class="token function">floatPower2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">149</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> <span class="token operator">-</span><span class="token number">126</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">149</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">127</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">;</span>         <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0xff</span> <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h1><p>&emsp;&emsp;以上就是CSAPP DataLab的全部内容了，做完这个实验也算是对之前一段时间学习的一个巩固和练习吧，对于逻辑门运算和浮点运算也有了更多的了解。</p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
          <category> Lab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/10/08/hello-world/"/>
      <url>/2023/10/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
