<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[深入理解计算机系统]CSAPP 第四章学习笔记</title>
      <link href="/2023/12/11/%5B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%5DCSAPP%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/11/%5B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%5DCSAPP%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解计算机系统-CSAPP-第四章学习笔记"><a href="#深入理解计算机系统-CSAPP-第四章学习笔记" class="headerlink" title="[深入理解计算机系统]CSAPP 第四章学习笔记"></a>[深入理解计算机系统]CSAPP 第四章学习笔记</h1><p>&emsp;&emsp;本人仍处于学习中，若有错误，恳请谅解。这里推荐一个B站宝藏UP主——九曲阑干，看他的视频给了我许多帮助，也希望可以帮助到你。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="指令集体系结构是什么"><a href="#指令集体系结构是什么" class="headerlink" title="指令集体系结构是什么"></a>指令集体系结构是什么</h3><p>&emsp;&emsp;处理器必须执行一系列指令，每条指令执行某个简单操作，如两个数相加。每一条指令会被编码为由一个或多个字节序列组成的二进制格式，即能被处理器识别的机器码。</p><p>&emsp;&emsp;<strong>一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构——ISA</strong>，也就是指令集架构、指令系统结构。</p><h3 id="指令集体系结构的作用"><a href="#指令集体系结构的作用" class="headerlink" title="指令集体系结构的作用"></a>指令集体系结构的作用</h3><p>&emsp;&emsp;指令集体系结构（ISA）是计算机软件和硬件交互的接口。</p><p>&emsp;&emsp;ISA 在编译器编写者（CPU软件）和处理器设计人员（CPU硬件）之间提供了一个概念抽象层，编译器编写者只需要知道允许那些指令，以及它们是如何编码的（即依据ISA了解CPU选用的指令集，明白可以使用那些指令，同时要遵循哪些规范）；而处理器设计者必须建造出执行这些指令的处理器（依据ISA来设计处理器）。</p><p>&emsp;&emsp;<strong>ISA最重要的内涵就是定义处理器上的软件如何构建。</strong></p><p>&emsp;&emsp;注：<strong>指令集并不储存于CPU中，事实是CPU本身是指令集体系结构（ISA）的一个实现实例。同时一个ISA可能有多个指令集。</strong></p><h3 id="Y86-64"><a href="#Y86-64" class="headerlink" title="Y86-64"></a>Y86-64</h3><p>&emsp;&emsp;本章定义了一个简单的指令集，通过x86-64的启发，所以命名为“Y86-64”。Y86-64不像x86-64那样复杂，该指令集的数据类型、指令和寻址方式都要少一些，并且字节级编码也比较简单。但是仍然足够完整。</p><h3 id="数字硬件设计"><a href="#数字硬件设计" class="headerlink" title="数字硬件设计"></a>数字硬件设计</h3><p>&emsp;&emsp;了解处理器中使用的基本构件块，以及它们如何连接起来和操作的。同时介绍一种描述硬件系统控制部分的简单语言——HCL。通过学习，具有对硬件逻辑设计的背景知识。</p><h3 id="顺序设计处理器"><a href="#顺序设计处理器" class="headerlink" title="顺序设计处理器"></a>顺序设计处理器</h3><p>&emsp;&emsp;给出一个基于顺序操作、功能正常但是有点不太实用的 Y86-64 处理器。该处理器每个时钟内可以执行一条完整的 Y86-64 指令。所以它的时钟必须足够慢，以允许在一个周期内完成所有动作。</p><h3 id="流水线化处理器"><a href="#流水线化处理器" class="headerlink" title="流水线化处理器"></a>流水线化处理器</h3><p>&emsp;&emsp;以顺序设计为基础，我们进行升级改造，创建一个流水化线的处理器。</p><h2 id="Y86-64指令集体系结构"><a href="#Y86-64指令集体系结构" class="headerlink" title="Y86-64指令集体系结构"></a>Y86-64指令集体系结构</h2><h3 id="程序员可见的状态"><a href="#程序员可见的状态" class="headerlink" title="程序员可见的状态"></a>程序员可见的状态</h3><p>&emsp;&emsp;什么是程序员的可见状态？</p><p>&emsp;&emsp;首先，这里的程序员既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器。</p><p>&emsp;&emsp;其次，可见状态是指<strong>每一条指令都会去读取或修改处理器的某些部分</strong>。例如内存、寄存器、条件码、程序计数器以及程序状态等。</p><p>&emsp;&emsp;在Y86-64指令系统中，我们定义了15个64位的程序寄存器，相较于第三章中熟悉的x86-64的指令系统少了一个 %r15 ，是为了降低指令编码的复杂度。每个程序寄存器存储一个64位的字。寄存器 %rsp 被入栈、出栈、调用和返回指令作为栈指针。其余的没有固定的含义或固定值。</p><p>&emsp;&emsp;同时Y86-64的指令系统还简化了条件码寄存器，只有 3 个一位的条件码：ZF、SF、OF，它们保存着最近的算术或逻辑指令所造成影响的有关信息。</p><p>&emsp;&emsp;<strong>程序计数器（PC）是用来存放当前正在执行指令的地址。</strong></p><p>&emsp;&emsp;然后关于内存，从概念上来说，内存实际上就是一个很大的字节数组，保存着程序和数据。Y86-64 程序采用 <strong>虚拟地址</strong> 来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或 <strong>物理地址</strong> ，指明数据实际存在内存中哪个地方。</p><p>&emsp;&emsp;最后就是程序状态了，程序状态的最后一个部分是状态码Stat，它是用来表明程序执行的总状态。是正常运行呢，还是出现了异常。</p><p><img src="/imgs/$%7BuseImgs%7D/img_11.png" alt=""></p><h3 id="Y86-64指令"><a href="#Y86-64指令" class="headerlink" title="Y86-64指令"></a>Y86-64指令</h3><p>&emsp;&emsp;类比x86-64的指令集，Y86-64指令集做了一些相应的简化。</p><h4 id="1-数据传送指令"><a href="#1-数据传送指令" class="headerlink" title="1.数据传送指令"></a>1.数据传送指令</h4><p>&emsp;&emsp;x86-64中的 movq 指令分成了4个不同的指令：irmovq 、rrmovq 、mrmovq 和 rmmovq，分别显示地指明源和目的的格式。</p><p>&emsp;&emsp;指令名字的第一个字母表明源操作数的类型，第二个字母表明目的操作数的类型。</p><p>&emsp;&emsp;源操作数可以是立即数（i：immediate）、寄存器（r：register)、内存（m：memory），而目的操作数可以是寄存器（r：register）、内存（m：memory）。</p><p><img src="/imgs/$%7BuseImgs%7D/img_7.png" alt=""></p><p>&emsp;&emsp;注：两个内存传送指令（mrmovq、rmmovq）中的内存引用方式是简单的基址和偏移量形式。同时，在地址计算中，不支持第二变址寄存器和任何寄存器的伸缩。</p><p>&emsp;&emsp;与x86-64一样，不允许从一个内存地址直接传送到另一个内存地址。另外，也不允许将立即数传送到内存。</p><h4 id="2-整数操作指令"><a href="#2-整数操作指令" class="headerlink" title="2.整数操作指令"></a>2.整数操作指令</h4><p>&emsp;&emsp;在Y86-64中，我们有4个整数操作指令，它们是addq、subq、andq 和 xorq。它们只对寄存器数据进行操作，而x86-64还允许对内存数据进行这些操作。这些指令会设置 3 个条件码 ZF 、SF  和 OF（零、符号和溢出）。其字节级编码如下：</p><p><img src="/imgs/$%7BuseImgs%7D/img_8.png" alt=""></p><h4 id="3-跳转指令"><a href="#3-跳转指令" class="headerlink" title="3.跳转指令"></a>3.跳转指令</h4><p>&emsp;&emsp;在Y86-64中，我们有7个跳转指令，分别是 jmp 、jle 、jl 、je、jne、jge 和 jg。根据分支指令的类型和条件代码的设置来选择分支。分支条件和 x86-64 一样。如下图所示：</p><p><img src="/imgs/$%7BuseImgs%7D/img_12.png" alt=""></p><h4 id="4-条件传送指令"><a href="#4-条件传送指令" class="headerlink" title="4.条件传送指令"></a>4.条件传送指令</h4><p>&emsp;&emsp;在 Y86-64 中，我们定义了6个条件传送指令：comvle、cmovl、cmove、cmovne、cmovge、cmovg。这些指令的格式与寄存器-寄存器传送指令 rrmovq 一样，<strong>但是只有当条件代码满足所需要的约束时，才会更新目的寄存器的值。</strong></p><p>&emsp;&emsp;其字节级编码如下：<img src="/imgs/$%7BuseImgs%7D/img_15.png" alt=""></p><h4 id="5-其他指令"><a href="#5-其他指令" class="headerlink" title="5.其他指令"></a>5.其他指令</h4><p>&emsp;&emsp;call指令会将返回地址入栈，然后跳到目的地址。ret 指令从这样的调用中返回。</p><p>&emsp;&emsp;pushq 和 popq 指令实现了入栈和出栈，就像在 x86-64 中一样。</p><p>&emsp;&emsp;halt 指令停止指令的执行。x86-64 中有一个与之相当的指令 hlt。x86-64 的应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。对于 Y86-64 来说，执行halt 指令会导致处理器停止，并将状态码设置为 HLT 。</p><p>&emsp;&emsp;其字节级编码如下：<img src="/imgs/$%7BuseImgs%7D/img_16.png" alt=""></p><h3 id="指令编码"><a href="#指令编码" class="headerlink" title="指令编码"></a>指令编码</h3><p><img src="/imgs/$%7BuseImgs%7D/img_6.png" alt=""></p><p>&emsp;&emsp;上图给出了上述指令的字节级编码。每条指令需要1~10个字节不等，这取决于需要哪些字段。</p><ol><li><p>每条指令的第一个字节表明指令的类型。</p></li><li><p>该字节分为两部分，每一部分占4个比特位，高四位表示指令代码，低四位表示指令功能。</p></li><li><p>不同的指令代码表示不同的指令，指令的功能部分都为 0 。</p></li><li><p>当指令中有寄存器类型的操作数时，回附加一个字节，该字节被称为寄存器指示符字节，用于指定一个或者两个寄存器，因此还需要对寄存器进行编码。</p></li><li><p>Y86-64指令系统中，我们定义了15个寄存器，每个寄存器不仅定义了名字，还为每一个寄存器指定一个编号。使用十六进制数 0 ~ 0xE 来表示。</p></li></ol><p><img src="/imgs/$%7BuseImgs%7D/img_13.png" alt=""></p><p>&emsp;&emsp;<strong>指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。</strong></p><h3 id="Y86-64-异常"><a href="#Y86-64-异常" class="headerlink" title="Y86-64 异常"></a>Y86-64 异常</h3><p>&emsp;&emsp;对 Y86-64 来说，程序员可见状态包括状态码 Stat ，它描述程序执行的总体状态。这个代码可能的值如下图所示：</p><p><img src="/imgs/$%7BuseImgs%7D/img_14.png" alt=""></p><p>出现某种异常时，Stat 的值会变为相对应的值，同时也会被命名为相对应的名字。在遇到这些异常的时候，我们就只是简单的让处理器停止执行指令。</p><h3 id="Y86-64-程序"><a href="#Y86-64-程序" class="headerlink" title="Y86-64 程序"></a>Y86-64 程序</h3><p>&emsp;&emsp;x86-64代码是由GCC编译器产生的。Y86-64代码与之类似，但又以下不同点：</p><ul><li>Y86-64将常数加载到寄存器（第2~6行），因为它在算术指令中不能使用立即数。</li><li>要实现从内存读取一个数值并将其与一个寄存器相加，Y86-64代码需要两条指令（第8~9行），而x86-64只需要一条 addq 指令（第5行）。</li><li>手工编写的Y86-64实现有一个优势，即 subq 指令（第11行）同时还设置了条件码，因此GCC生成代码中的 testq 指令（第9行）就不是必需的。不过为此，Y86-64必须使用 andq 指令（第5行）在进入循环之前设置条件码。</li></ul><p><img src="/imgs/$%7BuseImgs%7D/img_17.png" alt=""></p><p>&emsp;&emsp;程序寄存器：从本质上来讲它属于处理器内部的存储单元，通常我们将寄存器的集合称为寄存器文件，有的资料中也称寄存器堆。</p><p>&emsp;&emsp;在处理器内部，寄存器文件和算术逻辑单元（ALU）是串联的，寄存器文文件的输出端口与 ALU 的输入端口相连。</p><p><img src="/imgs/$%7BuseImgs%7D/img_18.png" alt=""></p><p>&emsp;&emsp;下图展示了一个寄存器文件的功能表述：</p><ul><li>具有一个读端口和一个写端口，数据位宽为64位。</li><li>规定读写操作共用地址线，由于定义了15个程序寄存器，故地址线宽度设计成4位即可满足寻址要求。</li><li>此外，还有时钟信号、复位信号以及写使能信号。</li></ul><p><img src="/imgs/$%7BuseImgs%7D/img_19.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android]Jetpack Compose 实现仿裸眼3D</title>
      <link href="/2023/11/25/%5BAndroid%5DJetpack%20Compose%20%E5%AE%9E%E7%8E%B0%E4%BB%BF%E8%A3%B8%E7%9C%BC3D/"/>
      <url>/2023/11/25/%5BAndroid%5DJetpack%20Compose%20%E5%AE%9E%E7%8E%B0%E4%BB%BF%E8%A3%B8%E7%9C%BC3D/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;最近在学传感器的时候，看到了有大佬使用 Jetpack Compose 实现了一个仿裸眼3D的效果，十分的牛皮，看得我是心血来潮、热血澎湃，这里放上推荐链接：<a href="https://juejin.cn/post/6992169168938205191">Compose版来啦！仿自如裸眼3D效果 - 掘金 (juejin.cn)</a>。于是就也想拥有，所以按照大佬的思路，使用Android 传感器中的陀螺仪来进行一个实现。同时也可以去了解一下 Android 中传感器（Sensor）的使用，这里送上官方传感器文档：<a href="https://developer.android.google.cn/guide/topics/sensors?hl=zh-cn">传感器  | Android 开发者  | Android Developers (google.cn)</a>。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>&emsp;&emsp;根据上方大佬的思路，我们可以很好地理解的这个仿裸眼3D的原理，简单来说，就是将一张图进行抠图，将其分为前、中、后三个图层（也可以是自己找的三个元素），然后使用 Canvas 里面的 drawImage 函数将三张图画出（使用这个方法加载图片方便进行位移）。</p><p>&emsp;&emsp;接着对前、后图层使用 translate 函数，通过设置位移量来实现图层的移动，所以只需要通过改变位移量就可以对图片进行位移。这里要注意，要实现仿裸眼3D，就需要在前层图片往一个方向移动时，后层图片向另一个方向移动，中层图片则不动，所以对于前层和后层的 translate 函数的传值要对应取反。</p><p>&emsp;&emsp;于是现在就需要实现在翻转手机时，为 translate 函数提供相应的位移量。就使用到了陀螺仪传感器，在转动手机时，传感器会传回 x、y、z 三个方向（判断方向如下图所示）的角速度，往正方向翻转会传回一个正的角速度，往负方向翻转会传回一个负的角速度。</p><p><img src="/imgs/$%7BuseImgs%7D/img_9.png" alt=""></p><p>&emsp;&emsp;得到了这个方向上的角速度，就可以由一个基本的物理公式 $\omega = \frac{<em>{\Delta }\Theta  }{</em>{\Delta}t} $ 求出所转过的角度（rad）是多少（若不熟悉弧度制，可使用 Math 库中的 Degress 函数将弧度制转化为角度制），然后和大佬思路一致，设置最大角度和最大平移距离（可以根据自己的），通过</p><script type="math/tex; mode=display">{\color{Violet} \frac{旋转角度}{最大旋转角度} = \frac{平移距离}{最大平移距离}}</script><p>求出该旋转角度下图片的平移距离。</p><p>&emsp;&emsp;为了获取角度值，就需要得到时间，不用担心，在官方文档介绍陀螺仪的部分中，其示例中就有对时间的积累，即获取时间。如下</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> NS2S <span class="token operator">=</span> <span class="token number">1.0f</span> <span class="token operator">/</span> <span class="token number">1000000000.0f</span><span class="token keyword">var</span> timestamp<span class="token operator">:</span> Float <span class="token operator">=</span> <span class="token number">0f</span>sensorManager<span class="token punctuation">.</span><span class="token function">registerListener</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> SensorEventListener<span class="token punctuation">&#123;</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onSensorChanged</span><span class="token punctuation">(</span>event<span class="token operator">:</span> SensorEvent<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// This timestep's delta rotation to be multiplied by the current rotation</span>            <span class="token comment">// after computing it from the gyro sample data.</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>timestamp <span class="token operator">!=</span> <span class="token number">0f</span> <span class="token operator">&amp;&amp;</span> event <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">val</span> dT <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>timestamp <span class="token operator">-</span> timestamp<span class="token punctuation">)</span> <span class="token operator">*</span> NS2S                <span class="token comment">/*                *中间省略大部分                */</span>            <span class="token punctuation">&#125;</span>            timestamp <span class="token operator">=</span> event<span class="token operator">?</span><span class="token punctuation">.</span>timestamp<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">toFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?:</span> <span class="token number">0f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可以开始实操了。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="三层图片绘制"><a href="#三层图片绘制" class="headerlink" title="三层图片绘制"></a>三层图片绘制</h2><p>&emsp;&emsp;按照上面的思路，首先需要有三层的图片，然后把他们绘制在一起，然后对前层与后层的图片加上 translate 函数用于平移。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">const</span> <span class="token keyword">val</span> NS2S <span class="token operator">=</span> <span class="token number">1.0f</span> <span class="token operator">/</span> <span class="token number">1000000000.0f</span><span class="token keyword">private</span> <span class="token keyword">var</span> timestamp <span class="token operator">:</span> Float <span class="token operator">=</span> <span class="token number">0f</span><span class="token keyword">private</span> <span class="token keyword">const</span> <span class="token keyword">val</span> maxAngle <span class="token operator">:</span> Float <span class="token operator">=</span> <span class="token number">60f</span>          <span class="token comment">//设置最大角度，我使用的是角度制</span><span class="token keyword">private</span> <span class="token keyword">const</span> <span class="token keyword">val</span> maxOffset <span class="token operator">:</span> Float <span class="token operator">=</span> <span class="token number">100f</span>        <span class="token comment">//设置最大平移距离  </span><span class="token annotation builtin">@Composable</span><span class="token keyword">fun</span> <span class="token function">ClassFree3D</span><span class="token punctuation">(</span>    sensorManager<span class="token operator">:</span> SensorManager<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> imageBack <span class="token operator">=</span> ImageBitmap<span class="token punctuation">.</span><span class="token function">imageResource</span><span class="token punctuation">(</span>id <span class="token operator">=</span> R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>imgback<span class="token punctuation">)</span>    <span class="token keyword">val</span> imageMid <span class="token operator">=</span> ImageBitmap<span class="token punctuation">.</span><span class="token function">imageResource</span><span class="token punctuation">(</span>id <span class="token operator">=</span> R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>imgmid<span class="token punctuation">)</span>    <span class="token keyword">val</span> imageFore <span class="token operator">=</span> ImageBitmap<span class="token punctuation">.</span><span class="token function">imageResource</span><span class="token punctuation">(</span>id <span class="token operator">=</span> R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>imgfore<span class="token punctuation">)</span>        <span class="token keyword">var</span> xDistance <span class="token keyword">by</span> remember <span class="token punctuation">&#123;</span> <span class="token function">mutableFloatStateOf</span><span class="token punctuation">(</span><span class="token number">0f</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">var</span> yDistance <span class="token keyword">by</span> remember <span class="token punctuation">&#123;</span> <span class="token function">mutableFloatStateOf</span><span class="token punctuation">(</span><span class="token number">0f</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>    <span class="token function">Box</span><span class="token punctuation">(</span>modifier <span class="token operator">=</span> Modifier<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">Canvas</span><span class="token punctuation">(</span>            modifier <span class="token operator">=</span> Modifier                <span class="token punctuation">.</span><span class="token function">fillMaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">//通过设置scale设置图片边界，防止在平移过程中图片平移过大导致露出屏幕背景</span>                <span class="token punctuation">.</span><span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">1.3f</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">translate</span><span class="token punctuation">(</span><span class="token operator">-</span>yDistance<span class="token punctuation">,</span><span class="token operator">-</span>xDistance<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">//对于前层取反，实现反向移动</span>                <span class="token function">drawImage</span><span class="token punctuation">(</span>imageBack<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            <span class="token function">drawImage</span><span class="token punctuation">(</span>                image <span class="token operator">=</span> imageMid<span class="token punctuation">,</span>                <span class="token comment">//这里通过 drawImage 同时对图片进行一个定位，使三张图片组合得好看</span>                dstOffset <span class="token operator">=</span> <span class="token function">IntOffset</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">,</span>y <span class="token operator">=</span> <span class="token number">350</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                dstSize <span class="token operator">=</span> <span class="token function">IntSize</span><span class="token punctuation">(</span>width <span class="token operator">=</span> imageMid<span class="token punctuation">.</span>width <span class="token operator">-</span> <span class="token number">1000</span><span class="token punctuation">,</span> height <span class="token operator">=</span> imageMid<span class="token punctuation">.</span>height <span class="token operator">-</span> <span class="token number">300</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span>            <span class="token function">translate</span><span class="token punctuation">(</span>yDistance<span class="token punctuation">,</span>xDistance<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">drawImage</span><span class="token punctuation">(</span>                    image <span class="token operator">=</span> imageFore<span class="token punctuation">,</span>                    <span class="token comment">//与上面同理</span>                    dstOffset <span class="token operator">=</span> <span class="token function">IntOffset</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>y <span class="token operator">=</span> <span class="token number">480</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    dstSize <span class="token operator">=</span> <span class="token function">IntSize</span><span class="token punctuation">(</span>width <span class="token operator">=</span> imageFore<span class="token punctuation">.</span>width <span class="token operator">-</span> <span class="token number">200</span><span class="token punctuation">,</span> height <span class="token operator">=</span> imageFore<span class="token punctuation">.</span>height<span class="token punctuation">)</span>                <span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>平面绘制出来的图片如下所示（本人直男审美，可根据个人喜爱自由发挥。）</p><p><img src="/imgs/$%7BuseImgs%7D/img_10.png" alt=""></p><h2 id="陀螺仪获取角速度"><a href="#陀螺仪获取角速度" class="headerlink" title="陀螺仪获取角速度"></a>陀螺仪获取角速度</h2><p>&emsp;&emsp;Android为我们提供了一个 SensorManager 类来管理所有的传感器。故可以在主活动中获取一个 sensorManager 将其传给我们的这个组件，再在这个组件中获取陀螺仪传感器，并对其进行注册监听事件，获取翻转时的角速度和时间。</p><p>&emsp;&emsp;在主活动中获取 sensorManager：</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> sensorManager <span class="token operator">=</span> <span class="token function">getSystemService</span><span class="token punctuation">(</span>Context<span class="token punctuation">.</span>SENSOR_SERVICE<span class="token punctuation">)</span> <span class="token keyword">as</span> SensorManager<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&emsp;&emsp;将其传入组件：</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token function">ClassFree3D</span><span class="token punctuation">(</span>sensorManager <span class="token operator">=</span> sensorManager<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&emsp;&emsp;然后再组件中获取陀螺仪传感器并注册监听器，获取角速度的累积，乘以时间，获取x、y、z三个方向的角度。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> sensor <span class="token operator">=</span> sensorManager<span class="token punctuation">.</span><span class="token function">getDefaultSensor</span><span class="token punctuation">(</span>Sensor<span class="token punctuation">.</span>TYPE_GYROSCOPE<span class="token punctuation">)</span><span class="token keyword">var</span> angularX <span class="token keyword">by</span> remember <span class="token punctuation">&#123;</span> <span class="token function">mutableFloatStateOf</span><span class="token punctuation">(</span><span class="token number">0f</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token keyword">var</span> angularY <span class="token keyword">by</span> remember <span class="token punctuation">&#123;</span> <span class="token function">mutableFloatStateOf</span><span class="token punctuation">(</span><span class="token number">0f</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token keyword">var</span> angularZ <span class="token keyword">by</span> remember <span class="token punctuation">&#123;</span> <span class="token function">mutableFloatStateOf</span><span class="token punctuation">(</span><span class="token number">0f</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>sensorManager<span class="token punctuation">.</span><span class="token function">registerListener</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> SensorEventListener<span class="token punctuation">&#123;</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onSensorChanged</span><span class="token punctuation">(</span>event<span class="token operator">:</span> SensorEvent<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>timestamp <span class="token operator">!=</span> <span class="token number">0f</span> <span class="token operator">&amp;&amp;</span> event <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">val</span> dT <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>timestamp <span class="token operator">-</span> timestamp<span class="token punctuation">)</span> <span class="token operator">*</span> NS2S                angularX <span class="token operator">+=</span> event<span class="token punctuation">.</span>values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> dT                angularY <span class="token operator">+=</span> event<span class="token punctuation">.</span>values<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> dT                angularZ <span class="token operator">+=</span> event<span class="token punctuation">.</span>values<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> dT<span class="token comment">//这里将弧度制转化为角度制</span>                <span class="token keyword">var</span> angleX <span class="token operator">:</span> Float <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">toDegrees</span><span class="token punctuation">(</span>angularX<span class="token punctuation">.</span><span class="token function">toDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">var</span> angleY <span class="token operator">:</span> Float <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">toDegrees</span><span class="token punctuation">(</span>angularY<span class="token punctuation">.</span><span class="token function">toDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">var</span> angleZ <span class="token operator">:</span> Float <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">toDegrees</span><span class="token punctuation">(</span>angularZ<span class="token punctuation">.</span><span class="token function">toDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            timestamp <span class="token operator">=</span> event<span class="token operator">?</span><span class="token punctuation">.</span>timestamp<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">toFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?:</span> <span class="token number">0f</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onAccuracyChanged</span><span class="token punctuation">(</span>sensor<span class="token operator">:</span> Sensor<span class="token operator">?</span><span class="token punctuation">,</span> accuracy<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>sensor<span class="token punctuation">,</span>SensorManager<span class="token punctuation">.</span>SENSOR_STATUS_ACCURACY_LOW<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="进行运算"><a href="#进行运算" class="headerlink" title="进行运算"></a>进行运算</h2><p>&emsp;&emsp;然后由上面的公式进行运算，通过角度获得平移距离，同时也设置了最大的角度，这样就有最大的平移距离，这样可以防止平移距离过大而导致屏幕背景暴露。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">if</span> <span class="token punctuation">(</span>angleY <span class="token operator">></span> maxAngle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        angleY <span class="token operator">=</span> maxAngle    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>angleY <span class="token operator">&lt;</span> <span class="token operator">-</span>maxAngle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        angleY <span class="token operator">=</span> <span class="token operator">-</span>maxAngle    <span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>angleX <span class="token operator">></span> maxAngle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        angleX <span class="token operator">=</span> maxAngle    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>angleX <span class="token operator">&lt;</span> <span class="token operator">-</span>maxAngle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        angleX <span class="token operator">=</span> <span class="token operator">-</span>maxAngle    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> xRadio <span class="token operator">:</span> Float <span class="token operator">=</span> <span class="token punctuation">(</span>angleX <span class="token operator">/</span> maxAngle<span class="token punctuation">)</span>    <span class="token keyword">val</span> yRadio <span class="token operator">:</span> Float <span class="token operator">=</span> <span class="token punctuation">(</span>angleY <span class="token operator">/</span> maxAngle<span class="token punctuation">)</span>    xDistance <span class="token operator">=</span> xRadio <span class="token operator">*</span> maxOffset    yDistance <span class="token operator">=</span> yRadio <span class="token operator">*</span> maxOffset<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;这样就在手机每次翻转的时候都会获取新的角度，从而改变平移距离，这样图片就可以随时发生平移，实现了仿裸眼3D的功能。</p><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p>&emsp;&emsp;这里直接展示</p><center><img src="/imgs/$%7BuseImgs%7D/gif_4.gif" width = "" height = ""></center><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;说实话，实现之后自己都觉得很好看，同时也知道了如何去操作陀螺仪传感器，这也可以去实现许多交互上的创意。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Compose </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Android]Jetpack Compose 实现Banner轮播图</title>
      <link href="/2023/11/20/%5BAndroid%5DJetpack%20Compose%20%E5%AE%9E%E7%8E%B0Banner%E8%BD%AE%E6%92%AD%E5%9B%BE/"/>
      <url>/2023/11/20/%5BAndroid%5DJetpack%20Compose%20%E5%AE%9E%E7%8E%B0Banner%E8%BD%AE%E6%92%AD%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;Jetpack Compose 是推荐用于构建原生 Android 界面的新工具包。它可简化并加快 Android 上的界面开发，使用更少的代码、强大的工具和直观的 Kotlin API，快速打造生动而精彩的应用。</p><p>&emsp;&emsp;本次就使用 Jetpack Compose里面的分页器（pager）来实现一个常用控件——轮播图（Banner）。这里需要对Android Compose有一定的了解，可以先去学习一下Compose的基本知识，这里放上官方直达：<a href="https://developer.android.google.cn/jetpack/compose?hl=zh-cn">直达官方Compose</a> 。</p><p>&emsp;&emsp;同时这里也放上分页器的官方文档，可以了解更多高级功能，直达：<a href="https://developer.android.google.cn/jetpack/compose/layouts/pager?hl=zh-cn#custom-page">官方分页器文档</a>。</p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>&emsp;&emsp;首先需要分析一下实现轮播图的功能。</p><p>&emsp;&emsp;轮播图需要一直循环滑动播放，所以首先就是需要一个具有单页水平滑动效果的控件。在2023年3月底，Google 正式发布Jetpack Compose 的 1.4 版本，在这次的更新中，新增了 pager 等控件，它实现了View中ViewPager类似的功能。因此，水平分页器—— HorizontalPager 可以完美起这个重任。</p><p>&emsp;&emsp;可以分析一下HorizontalPager的源码</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Composable</span><span class="token annotation builtin">@ExperimentalFoundationApi</span><span class="token keyword">fun</span> <span class="token function">HorizontalPager</span><span class="token punctuation">(</span>    state<span class="token operator">:</span> PagerState<span class="token punctuation">,</span>    modifier<span class="token operator">:</span> Modifier <span class="token operator">=</span> Modifier<span class="token punctuation">,</span>    contentPadding<span class="token operator">:</span> PaddingValues <span class="token operator">=</span> <span class="token function">PaddingValues</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span><span class="token punctuation">,</span>    pageSize<span class="token operator">:</span> PageSize <span class="token operator">=</span> PageSize<span class="token punctuation">.</span>Fill<span class="token punctuation">,</span>    beyondBoundsPageCount<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    pageSpacing<span class="token operator">:</span> Dp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">.</span>dp<span class="token punctuation">,</span>    verticalAlignment<span class="token operator">:</span> Alignment<span class="token punctuation">.</span>Vertical <span class="token operator">=</span> Alignment<span class="token punctuation">.</span>CenterVertically<span class="token punctuation">,</span>    flingBehavior<span class="token operator">:</span> SnapFlingBehavior <span class="token operator">=</span> PagerDefaults<span class="token punctuation">.</span><span class="token function">flingBehavior</span><span class="token punctuation">(</span>state <span class="token operator">=</span> state<span class="token punctuation">)</span><span class="token punctuation">,</span>    userScrollEnabled<span class="token operator">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    reverseLayout<span class="token operator">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    key<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>index<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">-></span> Any<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span>    pageNestedScrollConnection<span class="token operator">:</span> NestedScrollConnection <span class="token operator">=</span>     PagerDefaults<span class="token punctuation">.</span><span class="token function">pageNestedScrollConnection</span><span class="token punctuation">(</span>        Orientation<span class="token punctuation">.</span>Horizontal    <span class="token punctuation">)</span><span class="token punctuation">,</span>    pageContent<span class="token operator">:</span> <span class="token annotation builtin">@Composable</span> PagerScope<span class="token punctuation">.</span><span class="token punctuation">(</span>page<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;其中最重要的当然是PagerState，顾名思义，这个就是用来管理HorizontalPager内pager状态的。这里是HorizontalPager的简单使用。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"> <span class="token comment">// 显示 10 个项目</span> <span class="token function">HorizontalPager</span><span class="token punctuation">(</span>pageCount <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> page <span class="token operator">-></span>     <span class="token comment">// 每一页的内容，比如显示个文本</span>     <span class="token function">Text</span><span class="token punctuation">(</span>         text <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Page: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">page</span></span><span class="token string">"</span></span><span class="token punctuation">,</span>         modifier <span class="token operator">=</span> Modifier<span class="token punctuation">.</span><span class="token function">fillMaxWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;然后就是在人没有对其进行滑动的时候，需要轮播图进行自动循环，并具有延迟展示图片内容。PagerState提供了方法可以获得当前Pager是否处于拖动状态。所以可以先使用这个方法获得当前状态，然后进行判断。延迟则可以使用delay函数来实现。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> isDragged <span class="token keyword">by</span> pagerState<span class="token punctuation">.</span>interactionSource<span class="token punctuation">.</span><span class="token function">collectIsDraggedAsState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&emsp;&emsp;最后还需要一个指示器，也可以使用 Box 或者 Canvas 简单实现，方法众多，可以尽情发挥。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>&emsp;&emsp;通过上面的分析，可以来实现轮播图Banner了，现在将实现分为三步。</p><h2 id="水平分页器"><a href="#水平分页器" class="headerlink" title="水平分页器"></a>水平分页器</h2><p>&emsp;&emsp;首先需要定义好Pager的数量——pagerCount。这里我定义了一个List用来存储图片的URL，之后也是使用了coil库来加载图片。因此，这里的 pagerCount 就等于 images.size。</p><p>&emsp;&emsp;接着就是定义 HorizontalPager 的 pagerState，直接使用 rememberPagerState，然后将 pagerCount 传入。</p><p>&emsp;&emsp;然后就可以使用HorizontalPager了，这里也设置了一下pageSpacing 来分隔此分页器中页面的空间量。同时写了个 BannerCard 来修饰一下图片，传入图片URL，然后使用 coil 的 AsyncImage 来加载图片。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token annotation builtin">@OptIn</span><span class="token punctuation">(</span>ExperimentalFoundationApi<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation builtin">@Composable</span><span class="token keyword">fun</span> <span class="token function">Banner</span><span class="token punctuation">(</span>    images<span class="token operator">:</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span>    autoScrollDuration<span class="token operator">:</span> Long <span class="token operator">=</span> <span class="token number">1500L</span>   <span class="token comment">//延迟的时间，可以自行设置，后面要用到。</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> pagerCount <span class="token operator">=</span> images<span class="token punctuation">.</span>size    <span class="token keyword">val</span> pagerState <span class="token operator">=</span> rememberPagerState<span class="token punctuation">&#123;</span>        pagerCount    <span class="token punctuation">&#125;</span>    Box <span class="token punctuation">&#123;</span>        <span class="token function">HorizontalPager</span><span class="token punctuation">(</span>            state <span class="token operator">=</span> pagerState<span class="token punctuation">,</span>            contentPadding <span class="token operator">=</span> <span class="token function">PaddingValues</span><span class="token punctuation">(</span>horizontal <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span><span class="token punctuation">,</span>            pageSpacing <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">.</span>dp        <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>index <span class="token operator">-></span>            <span class="token function">BannerCard</span><span class="token punctuation">(</span>                imageURL <span class="token operator">=</span> images<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span>                modifier <span class="token operator">=</span> Modifier                    <span class="token punctuation">.</span><span class="token function">padding</span><span class="token punctuation">(</span>top <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span>            <span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation builtin">@Composable</span><span class="token keyword">fun</span> <span class="token function">BannerCard</span><span class="token punctuation">(</span>    imageURL <span class="token operator">:</span> String<span class="token punctuation">,</span>    modifier <span class="token operator">:</span> Modifier<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">Card</span> <span class="token punctuation">(</span>modifier <span class="token operator">=</span> modifier<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">AsyncImage</span><span class="token punctuation">(</span>model <span class="token operator">=</span> imageURL<span class="token punctuation">,</span> contentDescription <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;实现效果如下</p><center><img src="/imgs/$%7BuseImgs%7D/gif_1.gif" width = "" height = ""></center><h2 id="自动循环与延迟"><a href="#自动循环与延迟" class="headerlink" title="自动循环与延迟"></a>自动循环与延迟</h2><p>&emsp;&emsp;首先先定义一个布尔类型的 isDragged 来获取是否处于拖动状态，然后对其进行判断，当没有人为拖动时，使用kotlin中的with 函数，在里面设立一个局部变量来储存当前页数的值，然后将其作为 LaunchedEffect （协程是Android kotlin开发中一个重要知识，在Compose中采用附带效应 effect 来实现协程开发）的参数，在协程使用 pagerState 的函数 animateScrollToPage 来实现自动滑动，nextPage 通过当前页数 + 1然后再对总页数取模来实现循环。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> isDragged <span class="token keyword">by</span> pagerState<span class="token punctuation">.</span>interactionSource<span class="token punctuation">.</span><span class="token function">collectIsDraggedAsState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>isDragged<span class="token punctuation">.</span><span class="token function">not</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">with</span><span class="token punctuation">(</span>pagerState<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">var</span> currentPageKey <span class="token keyword">by</span> remember <span class="token punctuation">&#123;</span> <span class="token function">mutableIntStateOf</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>            <span class="token function">LaunchedEffect</span><span class="token punctuation">(</span>key1 <span class="token operator">=</span> currentPageKey<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                launch <span class="token punctuation">&#123;</span>                    <span class="token function">delay</span><span class="token punctuation">(</span>timeMillis <span class="token operator">=</span> autoScrollDuration<span class="token punctuation">)</span>                    <span class="token keyword">val</span> nextPage <span class="token operator">=</span> <span class="token punctuation">(</span>currentPage <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mod</span><span class="token punctuation">(</span>pageCount<span class="token punctuation">)</span>                    <span class="token function">animateScrollToPage</span><span class="token punctuation">(</span>page <span class="token operator">=</span> nextPage<span class="token punctuation">)</span>                    currentPageKey <span class="token operator">=</span> nextPage                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;将其加入后再次启动（虚拟机！启动！！！）如下，发现已经可以自己循环播放了。</p><center><img src="/imgs/$%7BuseImgs%7D/gif_2.gif" width = "" height = ""></center><h2 id="添加指示器"><a href="#添加指示器" class="headerlink" title="添加指示器"></a>添加指示器</h2><p>&emsp;&emsp;添加指示器，本蒟蒻采用的是 Canvas 来实现。首先在一行中使用 repeat 函数进行重复，有多少张图就 repeat 多少次，即repeat（pageCount）,然后定义颜色，与当前页数相同的指示点颜色与其他点颜色进行区别，既然要画点，所以使用 Canvas 中的 drawCircle 来进行绘画，可以自行定义大小。</p><p>&emsp;&emsp;因为要使用pagerState来获得当前页数，所以指示器需要传入pagerState，和pagerCount。同时需要通过 modifier 修饰符将指示器放在父 Box 容器的底部，这样指示器就可以显示在图片的上方，并处于底部。</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token annotation builtin">@OptIn</span><span class="token punctuation">(</span>ExperimentalFoundationApi<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation builtin">@Composable</span><span class="token keyword">fun</span> <span class="token function">DotIndicators</span><span class="token punctuation">(</span>    pageCount <span class="token operator">:</span> Int<span class="token punctuation">,</span>    pagerState <span class="token operator">:</span> PagerState<span class="token punctuation">,</span>    modifier<span class="token operator">:</span> Modifier<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">Row</span> <span class="token punctuation">(</span>        modifier <span class="token operator">=</span> modifier<span class="token punctuation">.</span><span class="token function">padding</span><span class="token punctuation">(</span>bottom <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span><span class="token punctuation">,</span>        horizontalArrangement <span class="token operator">=</span> Arrangement<span class="token punctuation">.</span>Center<span class="token punctuation">,</span>        verticalAlignment <span class="token operator">=</span> Alignment<span class="token punctuation">.</span>Bottom    <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">repeat</span><span class="token punctuation">(</span>pageCount<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>iteration <span class="token operator">-></span>            <span class="token keyword">val</span> color <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pagerState<span class="token punctuation">.</span>currentPage <span class="token operator">==</span> iteration<span class="token punctuation">)</span> MaterialTheme<span class="token punctuation">.</span>colorScheme<span class="token punctuation">.</span>surface                           <span class="token keyword">else</span> MaterialTheme<span class="token punctuation">.</span>colorScheme<span class="token punctuation">.</span>onSurface            <span class="token function">Canvas</span><span class="token punctuation">(</span>                modifier <span class="token operator">=</span> Modifier                <span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">padding</span><span class="token punctuation">(</span>horizontal <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">.</span>dp<span class="token punctuation">)</span><span class="token punctuation">,</span> onDraw <span class="token operator">=</span> <span class="token punctuation">&#123;</span>                <span class="token function">drawCircle</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;最后再次启动！</p><center><img src="/imgs/$%7BuseImgs%7D/gif_3.gif" width = "" height = ""></center><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;如此如此，这般这般，就实现了轮播图的效果，如果任觉得不满于此，也可以跟随自己的想法去将其变得更加 niu pi。同时也可以多多探索。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Compose </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[深入理解计算机系统]CSAPP DataLab 学习记录</title>
      <link href="/2023/10/11/%5B%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%5DCSAPP%20DataLab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/10/11/%5B%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%5DCSAPP%20DataLab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p>&emsp;&emsp;最近在看完《深入理解计算机系统》前两章之后，也将其第一个Lab——DataLab完成了，于是来对此做一个记录。DataLab主要是对整型和浮点型的实验，其中对条件语句、算数运算还有逻辑运算进行了不同的限制。</p><h1 id="实验环境的搭建："><a href="#实验环境的搭建：" class="headerlink" title="实验环境的搭建："></a>实验环境的搭建：</h1><p>&emsp;&emsp;首先由于其实验环境是unix，我使用的是VMware Workstation + Ubuntu来搭建实验环境。VMware虚拟机和Ubuntu的安装可以看这篇博客<a href="https://blog.csdn.net/qq_41782425/article/details/85119258">VMware Ubuntu安装详细过程（详细图解）_vmware安装ubuntu-CSDN博客</a>，具体搭建过程可看这篇博客：<a href="https://blog.csdn.net/qq_39876147/article/details/124481740">【CSAPP】Lab0 - 环境配置_csapp 3e操作环境搭建_Luqwera的博客-CSDN博客</a>。</p><p>&emsp;&emsp;如果不想安装虚拟机，也可以使用Docker里的Linux容器来搭建，具体的操作过程可看这篇博客<a href="https://blog.csdn.net/qq_39029579/article/details/112169980">超详解 CS:APP:Lab1-DataLab_optional cmd line args-CSDN博客</a>。</p><p>&emsp;&emsp;完成环境的搭建后便可以开始做DataLab了。</p><h1 id="问题描述及解析："><a href="#问题描述及解析：" class="headerlink" title="问题描述及解析："></a>问题描述及解析：</h1><h2 id="1-bitXor"><a href="#1-bitXor" class="headerlink" title="1.bitXor"></a>1.bitXor</h2><p>&emsp;&emsp;题目的意思就是只使用 ~（取反符号） 和 &amp; （与运算符）来实现 ^ (异或)。</p><p>&emsp;&emsp;看到这个，首先想到了数字逻辑里的一个公式：</p><p><img src="/imgs/$%7BuseImgs%7D/img_1.png" alt=""></p><p>&emsp;&emsp;就是 “同或的非” = “异或”，但是里面有“或”运算符，所以要再使用一下德摩根定律：</p><p>​                                                                            <img src="/imgs/$%7BuseImgs%7D/img_2.png" alt=""></p><p>&emsp;&emsp;就可以解决这道题了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * bitXor - x^y using only ~ and &amp;  *   Example: bitXor(4, 5) = 1 *   Legal ops: ~ &amp; *   Max ops: 14 *   Rating: 1 */</span><span class="token keyword">int</span> <span class="token function">bitXor</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">~</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">~</span>x <span class="token operator">&amp;</span> <span class="token operator">~</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-tmin"><a href="#2-tmin" class="headerlink" title="2.tmin"></a>2.tmin</h2><p>&emsp;&emsp;题目的意思就是返回对32位 int 最小的二补数（就是补码）。下面是 n 比特的二补数系统中几个特别的数字：</p><div class="table-container"><table><thead><tr><th style="text-align:center">二补数</th><th style="text-align:center">实际数字</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">0111 1111 …. 1111</td><td style="text-align:center">$2^{n-1} -1$</td><td style="text-align:center">最大正数</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">0000 0000 …. 0001</td><td style="text-align:center">1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">0000 0000 …. 0000</td><td style="text-align:center">0</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">1111 1111 …. 1111</td><td style="text-align:center">-1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">1000 0000 …. 0000</td><td style="text-align:center">$-2^{n-1}$</td><td style="text-align:center">最小负数</td></tr></tbody></table></div><p>&emsp;&emsp;所以在32位的环境下，补码的最小值就是：Tmin = $-2^{32-1}$$=-2^{31}$。用十六进制表示就是0x80000000，及将 1 向左移 31位。这样就可以解决了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * tmin - return minimum two's complement integer  *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 4 *   Rating: 1 */</span><span class="token keyword">int</span> <span class="token function">tmin</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">31</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-isTmax"><a href="#3-isTmax" class="headerlink" title="3.isTmax"></a>3.isTmax</h2><p>&emsp;&emsp;这道题目需要你对输入的 x 进行判断是否为最大的补码，如果是就返回 1 ，不是则返回 0 。</p><p>&emsp;&emsp;由上一题可以知道，在32位的环境中最大的补码为 $2^{31}-1$ 及 0111 1111 …. 1111，所以我们可以从这个最大数入手。</p><p>&emsp;&emsp;首先可以发现 Tmax = 0111 1111 …. 1111 在加上一个 1 后会直接溢出变成 1000 0000 …. 0000，然后再对其取反后，就又变回了原来的 Tmax，故可以得到~(Tmax+1)= Tmax，因此，我们现在只需要判断~(x+1)与 x 是否相等就可以得出结论。但是题目限制无法使用等号，所以就可以利用异或运算的一个特性，即 x⊕x=0 ，就是两个相同的数进行异或后结果为 0 ，这里需要相同情况下返回 1，故要使用 ! 符号。所以最后组合在一起就是:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">^</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&emsp;&emsp;但是当你保存检测后发现没有通过。</p><p><img src="/imgs/$%7BuseImgs%7D/img_3.png" alt=""></p><p>&emsp;&emsp;仔细看了错误后会发现当 x = -1 时，返回的是 1 ，但应该是 0。这是因为在补码中 -1 = 1111 1111 …. 1111，-1+1 = 1 0000 0000 …. 0000 ，由于超过了32位的比特位，所以会被截断，高位进位无效，此时等于 0000 0000 …. 0000，即为0，而且正好每一位都与 -1的每一位互补。故需要我们来对 -1 进行特判。可以在 x+1 后对其进行 !! 操作来区别最大值和 -1 。</p><p>&emsp;&emsp;故最终解决方法如下。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* * isTmax - returns 1 if x is the maximum, two's complement number, *     and 0 otherwise  *   Legal ops: ! ~ &amp; ^ | + *   Max ops: 10 *   Rating: 1 */</span><span class="token keyword">int</span> <span class="token function">isTmax</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">^</span>x<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-allOddBits"><a href="#4-allOddBits" class="headerlink" title="4.allOddBits"></a>4.allOddBits</h2><p>&emsp;&emsp;该题的意思和上题差不多，就是判断 x 补码的奇数位是否全为 1，如果是就返回1，不是则返回0。并且告知了你32位是从第0位到第31位，所以不要判断错了。</p><p>&emsp;&emsp;读懂题意，就能想到用奇数位上全是1，偶数位上全为0的数，即0xAAAAAAAA与 x 进行与运算（&amp;），再看其结果是否任然等于0xAAAAAAAA，若相等，则 x 符合条件，返回1，不等则返回0。同样这一题与上一题一样，无法使用等号，所以继续使用异或来判断。但是需要注意本实验有一个要求</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*Integer constants 0 through 255 (0xFF), inclusive. You are      not allowed to use big constants such as 0xffffffff.*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;故无法直接定义 0xAAAAAAAA这么大的数，所以需要先得到0xAAAAAAAA。可以考虑用0xAA，通过移位和运算获得。之后就迎刃而解了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * allOddBits - return 1 if all odd-numbered bits in word set to 1 *   where bits are numbered from 0 (least significant) to 31 (most significant) *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 12 *   Rating: 2 */</span><span class="token keyword">int</span> <span class="token function">allOddBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0xAA</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> temp <span class="token operator">+</span> <span class="token punctuation">(</span>temp<span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token punctuation">(</span>a<span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token operator">^</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-negate"><a href="#5-negate" class="headerlink" title="5.negate"></a>5.negate</h2><p>&emsp;&emsp;这一题就是求 x 的相反数，一个很基础的结论就是~x + x = -1，调整一下就是 -x = ~x+1（牢记），补码的常见操作。</p><p>于是这题就解决了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * negate - return -x  *   Example: negate(1) = -1. *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 5 *   Rating: 2 */</span><span class="token keyword">int</span> <span class="token function">negate</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token operator">~</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-isAsciiDigit"><a href="#6-isAsciiDigit" class="headerlink" title="6.isAsciiDigit"></a>6.isAsciiDigit</h2><p>&emsp;&emsp;该题就是来判断 x 是否在 0x30 到 0x39 之间，如果是则返回 1。</p><p>&emsp;&emsp;思路就是先通过右移来判断除了后4位外，其余的位是否与0x3相同，将其作为第一个条件，然后来判断后四位是否在0到9之间。</p><p>&emsp;&emsp;第一个条件可以通过将 x 右移4位后与0x3进行异或来判断是否相同，第二条件就将 x 和0xF进行与运算这样就可以获得后四位所表示的数了，在将其减去10，即0xA，最后只用判断减去10后的结果的符号。由于无法使用减法，所以这里使用上一题的结论，加上-10就行，（-10 = ~10+1）。</p><p>&emsp;&emsp;最后可以通过右移31位获得结果的符号，若为负，则为-1，若为正，则为0，又因为任何一个数与-1进行与运算都会等于自己，所以第一个条件与第二个条件均成立时才会返回 1。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9') *   Example: isAsciiDigit(0x35) = 1. *            isAsciiDigit(0x3a) = 0. *            isAsciiDigit(0x05) = 0. *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 15 *   Rating: 3 */</span><span class="token keyword">int</span> <span class="token function">isAsciiDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">0x3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token operator">~</span><span class="token number">0xA</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> a <span class="token operator">&amp;</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-conditional"><a href="#7-conditional" class="headerlink" title="7.conditional"></a>7.conditional</h2><p>&emsp;&emsp;这一题就是使用允许的运算操作符：!  ~  &amp;  ^  |  +  &lt;&lt;  &gt;&gt;，来实现三目运算符，即当 x 为真时（x ≠ 0）返回 y ，为假时（x = 0），返回 z 。</p><p>&emsp;&emsp;首先可以先判断 x 为真为假，对 x 使用两次 ! 运算，若 x 为真，则此时为 1，反之，此时为 0。接着可以想到题目不是返回 y 就是返回 z ，所以可以想到使用或运算（|），现在需要我们在 x 为真时，将包含 z 的那一部分变为0，包含 y 的那一部分变为 y ，反之同理。然后可以想到任何一个数与 0 进行与运算都等于 0  ，任何一个数与 -1 进行与运算都等于自己本身。并且 ~0 = -1，~(-1) = 0，对于0 和 -1 都是 x 为假为真时进行取反操作可以得到的，故可以列出下表</p><div class="table-container"><table><thead><tr><th style="text-align:center">x</th><th style="text-align:center">a=!!x</th><th style="text-align:center">b=~a+1</th><th style="text-align:center">b&amp;y</th><th style="text-align:center">~b&amp;z</th><th style="text-align:center">（b&amp;y)$\vert$(~b&amp;z)</th></tr></thead><tbody><tr><td style="text-align:center">真</td><td style="text-align:center">1</td><td style="text-align:center">-1</td><td style="text-align:center">y</td><td style="text-align:center">0</td><td style="text-align:center">y</td></tr><tr><td style="text-align:center">假</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">z</td><td style="text-align:center">z</td></tr></tbody></table></div><p>&emsp;&emsp;可以发现完全符合题目所需，故解决方法如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * conditional - same as x ? y : z  *   Example: conditional(2,4,5) = 4 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 16 *   Rating: 3 */</span><span class="token keyword">int</span> <span class="token function">conditional</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>x<span class="token punctuation">;</span>  <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token operator">~</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>b <span class="token operator">&amp;</span> y<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token operator">~</span>b <span class="token operator">&amp;</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-isLessOrEqual"><a href="#8-isLessOrEqual" class="headerlink" title="8.isLessOrEqual"></a>8.isLessOrEqual</h2><p>&emsp;&emsp;通过题目的描述，需要我们来判断 x 与 y 的大小，如果 x &lt;= y 时返回1，否则返回0。</p><p>&emsp;&emsp;首先可以很快想到如果 x 是个负数， y 是个正数，那么 x 一定小于 y，则一定返回1，相反，当  x 为正，y为负，则一定返回0。所以可以先判断符号，通过右移31来获取符号位，但由于负数一般采用的是算术右移，所以最后都需要与1进行与运算，得到符号位。</p><p>&emsp;&emsp;接着使用异或来判断是否符号相同，若相同，则需要用 x 减去 y，即加上-y ，再来判断相减之后的符号位，但同时要注意到当x = y时，相减之后符号位为 0 ，与 x &lt; y时相减后情况不同，所以在此用了另一种方法，x &lt;= y等同于 x &lt; y+1，于是最后变为 x - y -1&lt; 0，同时 -y = ~y +1，所以最后求的就是 x + ~y 的符号了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * isLessOrEqual - if x &lt;= y  then return 1, else return 0  *   Example: isLessOrEqual(4,5) = 1. *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 24 *   Rating: 3 */</span><span class="token keyword">int</span> <span class="token function">isLessOrEqual</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">(</span>y<span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> diff <span class="token operator">=</span> a <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不同符号时,仅x为负，为y为正时，为1</span>  <span class="token keyword">int</span> same <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>  <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>same<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token operator">~</span>y<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> diff <span class="token operator">|</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-logicalNeg"><a href="#9-logicalNeg" class="headerlink" title="9.logicalNeg"></a>9.logicalNeg</h2><p>&emsp;&emsp;这里要求我们通过使用允许的运算操作符：~  &amp;  ^  |  +  &lt;&lt;  &gt;&gt;  来实现逻辑非操作（!），即对于 x ，只要 x 不为0 ，那么就返回 0，否则返回 1。</p><p>&emsp;&emsp;首先，需要知道一个不为0的数与自己的相反数进行或运算会等于一个负数，0与自己的相反数进行或运算结果还是 0 ，并且一个负数右移31位后结果为 -1 ，而 0右移31位后则还是 0，最后再加上一个1，那么就都符合题目的需求了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * logicalNeg - implement the ! operator, using all of  *              the legal operators except ! *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 *   Legal ops: ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 12 *   Rating: 4  */</span><span class="token keyword">int</span> <span class="token function">logicalNeg</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token operator">~</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">|</span>a<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-howManyBits"><a href="#10-howManyBits" class="headerlink" title="10.howManyBits"></a>10.howManyBits</h2><p>&emsp;&emsp;首先理解题意，要求求一个值使用补码来表示最少需要多少位。</p><p>通过对样例的分析可以得出结论，当 x 为正数时，在补码中位于最高位 1 之前的 0 是可以省略的，所以最少位数等于最高位 1 的位数加上 1 位符号位，而当 x 是一个负数时，同样的道理，位于最高位 0 之前的 1 也是可以省略的，所以此时最少位数等于最高位 0 的位数加上 1 位符号位，而对于 0 ，由于其补码没有符号位，所以表示只需 1 位。</p><p>&emsp;&emsp;按照上述过程，需要进行查找。为了方便统一，这里先将为负数的 x 取反，这样就和正数一样，只需找到最高位 1 后再加 1 位就行了，所以有如下操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> sign <span class="token operator">=</span> x<span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">;</span><span class="token comment">//先取符号位。</span>x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">~</span>sign<span class="token punctuation">)</span> <span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>sign <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//x为非负数则不变，x为负数则按位取反。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>&emsp;&emsp;接下来就是进行查找了，这里可以使用到二分的思想来进行查找，先看 x 最高的 16 位，将 x 进行右移 16 位，再将其规格化。</p><p>&emsp;&emsp;如果最高 16 位有 1 ，那么处理后的 x 就等于 1，故此时需要的位数至少为 16位，可以对该权值进行记录，只需要将处理后的 x 左移 4位，之后就对 <u>x 右移 16 位后的低16位</u>（注：此时的低16位就是原本 x 的高 16位）进行二分，将低 16 位中的高 8 位进行同样的操作，从而找到在 x 高16位中最高位 1。</p><p>&emsp;&emsp;如果没有 1 ，那么  x  处理后就等于 0 ，记录的值也等于 0 ，此时就不需要右移，而是在 x 的低 16 位中的高 8 位进行同样的操作。</p><p>&emsp;&emsp;综上，x 的右移操作可以总结为 x &gt;&gt; 本次记录的权值。以此类推，分别对高 8 位，4 位，2 位，1位进行同样操作。最后将所有权值进行相加，不要忘了在加一个 1 （对于非 0 数是加上 1 位的符号位，对于 0 是自己本身的 1 位。），此时就满足题目的要求了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* howManyBits - return the minimum number of bits required to represent x in *             two's complement *  Examples: howManyBits(12) = 5 *            howManyBits(298) = 10 *            howManyBits(-5) = 4 *            howManyBits(0)  = 1 *            howManyBits(-1) = 1 *            howManyBits(0x80000000) = 32 *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *  Max ops: 90 *  Rating: 4 */</span><span class="token keyword">int</span> <span class="token function">howManyBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> sign <span class="token operator">=</span> x<span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">;</span>  x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">~</span>sign<span class="token punctuation">)</span> <span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>sign <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> bit_16 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>  x <span class="token operator">=</span> x <span class="token operator">>></span> bit_16<span class="token punctuation">;</span>  <span class="token keyword">int</span> bit_8 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">;</span>  x <span class="token operator">=</span> x <span class="token operator">>></span> bit_8<span class="token punctuation">;</span>  <span class="token keyword">int</span> bit_4 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">;</span>  x <span class="token operator">=</span> x <span class="token operator">>></span> bit_4<span class="token punctuation">;</span>  <span class="token keyword">int</span> bit_2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">;</span>  x <span class="token operator">=</span> x <span class="token operator">>></span> bit_2<span class="token punctuation">;</span>  <span class="token keyword">int</span> bit_1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  x <span class="token operator">=</span> x<span class="token operator">>></span>bit_1<span class="token punctuation">;</span>  <span class="token keyword">int</span> bit_0 <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token keyword">int</span> ans <span class="token operator">=</span> bit_16<span class="token operator">+</span>bit_8<span class="token operator">+</span>bit_4<span class="token operator">+</span>bit_2<span class="token operator">+</span>bit_1<span class="token operator">+</span>bit_0<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-floatScale2"><a href="#11-floatScale2" class="headerlink" title="11.floatScale2"></a>11.floatScale2</h2><p>&emsp;&emsp;从这里开始就属于浮点数运算部分，首先得了解一下IEEE浮点表示，在IEEE浮点标准中用</p><script type="math/tex; mode=display">V=(-1)^{s} \times M\times 2^{E}</script><p>&emsp;&emsp;来表示一个数。其中 符号 s 表示正负（s=0表示正数，s=1表示负数），尾数M 是一个<strong>二进制小数</strong>，阶码 E 是对浮点数的加权，权重为 2 的 E 次幂（可能为负数）。因此将浮点数的位表示划分为三个部分。<img src="/imgs/$%7BuseImgs%7D/img_4.png" alt=""></p><p>&emsp;&emsp;一个单独的符号位 s 直接编码符号 s 。（此 s 非彼 s）</p><p>&emsp;&emsp;k 位的阶码字段exp 来编码阶码 E。</p><p>&emsp;&emsp;n 位小数字段 frac 编码位数 M ，但是编码出来的值也依赖阶码字段的值是否等于 0 。</p><p>&emsp;&emsp;根据 exp 的值，被编码的值可以分成三种情况，最后一种情况有两个变种。<img src="/imgs/$%7BuseImgs%7D/img_5.png" alt=""></p><p>&emsp;&emsp;其中小数字段 frac 被解释为描述小数值 f ，0 ≤ f &lt;1 ，用二进制表示为</p><script type="math/tex; mode=display">f = 0.f_{n-1}...f_{1}f_{0}</script><p>&emsp;&emsp;当 exp 的位模式既不全为 0，又不全为 1 时，则属于规格化的值，总结如下</p><script type="math/tex; mode=display">Bias=2^{k-1}-1</script><script type="math/tex; mode=display">E=e-Bias</script><script type="math/tex; mode=display">M=1+f</script><p>&emsp;&emsp;当 exp 全为 0 时，则属于非规格的值，总结如下</p><script type="math/tex; mode=display">Bias=2^{k-1}-1</script><script type="math/tex; mode=display">E=1-Bias</script><script type="math/tex; mode=display">M=f</script><p>&emsp;&emsp;当 exp 全为 1 时，属于特殊值，其中当小数域全为 0 时，表示的是无穷（∞），按照 s 的正负分为 +∞ 与 -∞ ；当小数域不为 0 时，结果被称为“NaN”，即不是一个数。 </p><p>&emsp;&emsp;现在可以来看这一题了，题目需要我们求出浮点数* 2 之后的值。</p><p>&emsp;&emsp;首先依据IEEE浮点数分别求出单精度浮点数的符号位、阶码位以及小数位。由上面可知 float 是32位，一般 s 为 1 位，exp 为 8 位，frac 为 23 位。可以通过位运算来获得，如下</p><pre class="line-numbers language-none"><code class="language-none">unsigned s &#x3D; (uf&gt;&gt;31)&amp;1;unsigned e &#x3D; (uf &amp; 0x7f800000)&gt;&gt;23;unsigned f &#x3D; (uf &amp; 0x7fffff);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;然后根据上面的三种情况进行分析，即规格化的值、非规格化的值以及特殊值。其中，当为特殊值时，两种情况都是可以直接返回的。当为非规格化的值时，那么值就为 0 或无穷小，直接<em> 2返回就行，f 此时就是尾码，所以就直接 f &lt;&lt;= 1。当为规格化的值时， 由IEEE浮点表达式可知，只需要将exp+1，那么E也会 + 1，最终就会实现</em>2的效果。</p><p>&emsp;&emsp;所以最终解决方法如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * floatScale2 - Return bit-level equivalent of expression 2*f for *   floating point argument f. *   Both the argument and result are passed as unsigned int's, but *   they are to be interpreted as the bit-level representation of *   single-precision floating point values. *   When argument is NaN, return argument *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while *   Max ops: 30 *   Rating: 4 */</span><span class="token keyword">unsigned</span> <span class="token function">floatScale2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">unsigned</span> s <span class="token operator">=</span> <span class="token punctuation">(</span>uf<span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> e <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">&amp;</span> <span class="token number">0x7f800000</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">23</span><span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> f <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">&amp;</span> <span class="token number">0x7fffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> ans<span class="token punctuation">;</span>  <span class="token comment">//特殊值，直接返回</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> uf<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//非规格化</span>      f <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>      ans <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token operator">&lt;&lt;</span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>e<span class="token operator">&lt;&lt;</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token operator">|</span>f<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token comment">//规格化</span>      e<span class="token operator">++</span><span class="token punctuation">;</span>      ans <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token operator">&lt;&lt;</span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>e<span class="token operator">&lt;&lt;</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token operator">|</span>f<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-floatFloat2Int"><a href="#12-floatFloat2Int" class="headerlink" title="12.floatFloat2Int"></a>12.floatFloat2Int</h2><p>&emsp;&emsp;这个函数让我们把一个给定的浮点数 uf 转换为 int 类型。因为 int 类型的范围相较于 float 小，所以会出现精度损失的情况。</p><p>首先还是和上一题一样，求出符号位 s ，阶吗 exp ，尾数 frac。再计算一下真实的阶数 E = exp - 127。如果 E &gt;=31 时，即为特殊值时，按照题目的要求返回 0x80000000u。 如果 E &lt; 0 时，即为非规格化的值时，此时 0&lt;= f &lt; 1，直接返回 0 。最后对于规格化的值，就按照正常处理，即</p><script type="math/tex; mode=display">V=(-1)^{s} \times M\times 2^{E}</script><p>&emsp;&emsp;先算出真实的尾数 M = frac | (1 &lt;&lt; 23)，同时 frac为23位，所以如果 E &gt;= 23则进行加权时，则要在frac的末尾加上（E - 23）个 0，若 E &lt; 23，则frac 末尾的（23-E）个数就无法保留，通过位运算可以实现。</p><p>&emsp;&emsp;同时还有一点需要注意，就是输入的数可能为负数，所以最后还需根据 s 的值进行判断。</p><p>&emsp;&emsp;最终代码如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * floatFloat2Int - Return bit-level equivalent of expression (int) f *   for floating point argument f. *   Argument is passed as unsigned int, but *   it is to be interpreted as the bit-level representation of a *   single-precision floating point value. *   Anything out of range (including NaN and infinity) should return *   0x80000000u. *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while *   Max ops: 30 *   Rating: 4 */</span><span class="token keyword">int</span> <span class="token function">floatFloat2Int</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//同样先获得符号s，尾数f，阶码e</span>  <span class="token keyword">unsigned</span> s <span class="token operator">=</span> <span class="token punctuation">(</span>uf<span class="token operator">>></span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0x1</span><span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> e <span class="token operator">=</span> <span class="token punctuation">(</span>uf<span class="token operator">>></span><span class="token number">23</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xff</span><span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> f <span class="token operator">=</span> uf <span class="token operator">&amp;</span> <span class="token number">0x7fffff</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> E <span class="token operator">=</span> e <span class="token operator">-</span> <span class="token number">127</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>E<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>E <span class="token operator">>=</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0x80000000u</span><span class="token punctuation">;</span>  <span class="token keyword">else</span><span class="token punctuation">&#123;</span>      f <span class="token operator">=</span> f <span class="token operator">|</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">23</span><span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>E<span class="token operator">&lt;</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           f <span class="token operator">>>=</span> <span class="token punctuation">(</span><span class="token number">23</span><span class="token operator">-</span>E<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>           f <span class="token operator">&lt;&lt;=</span> <span class="token punctuation">(</span>E<span class="token operator">-</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">-</span>f<span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">return</span> f<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="13-floatPower2"><a href="#13-floatPower2" class="headerlink" title="13.floatPower2"></a>13.floatPower2</h2><p>&emsp;&emsp;这一题要求计算浮点数2.0^x。因为在浮点数中阶码表示的意义正好就是2的多少次幂，所以我们想到对阶码出手。</p><p>&emsp;&emsp;但是需要先导出浮点数规格化和非规格化分别表示的浮点数的范围。</p><p>&emsp;&emsp;对于非规格化的 E = 1-Bias = 1- 127 = -126，而M的最小值则为0.000…1，等于 $2^{-23}$，所以非规格化浮点的最小值为 2 的 -149 次方，M的最大值则等于 $1-2^{-23}$，所以非规格化的浮点最大为 $2^{-126}\times(1-2^{-23})$。</p><p>&emsp;&emsp;对于规格化的浮点，M的最小值为 1 ，E 的最小值为 1- 127 = -126，所以最小为 $2^{-126}$ 。M 的最大值为 1.111…11，E 的最大值为 127，故规格化的浮点最大值不到 $2^{128}$。</p><p>&emsp;&emsp;就可以得到下表</p><div class="table-container"><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th></tr></thead><tbody><tr><td style="text-align:center">规格化</td><td style="text-align:center">$2^{-126}$</td><td style="text-align:center">$2^{127}\times(2-2^{-23})$</td></tr><tr><td style="text-align:center">非规格化</td><td style="text-align:center">$2^{-149}$</td><td style="text-align:center">$2^{-126}\times(1-2^{-23})$</td></tr></tbody></table></div><p>&emsp;&emsp;所以</p><ol><li><p>x &gt; 127时，返回NaN 。</p></li><li><p>x &lt;= -149时，返回 0。</p></li><li><p>-126 &lt;= x &lt;= 127时，为规格化的，就直接让尾码全为0，控制阶码就可以了，由 x = expr - bias 可得 exp = x+ 127 。</p></li><li><p>-149  &lt; x &lt; -126时，为非规格化的，阶码值 E = 1 - bias = -126。这个时候只能通过控制尾码来计算。由 </p><script type="math/tex; mode=display">M\times2^{-126}=2^{x}</script><p>可以推断出 $M=2^{x+126}$ 。尾码的值是二次幂的形式，所以可以通过一个“1”左移获得，就可以设 1 左移了 n 位，则 $x+126 = -(23-n)$，等到n = x+ 149。</p><p>故最终解决方法如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*       * floatPower2 - Return bit-level equivalent of the expression 2.0^x      *   (2.0 raised to the power x) for any 32-bit integer x.      *      *   The unsigned value that is returned should have the identical bit      *   representation as the single-precision floating-point number 2.0^x.      *   If the result is too small to be represented as a denorm, return      *   0. If too large, return +INF.      *       *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while       *   Max ops: 30       *   Rating: 4      */</span>     <span class="token keyword">unsigned</span> <span class="token function">floatPower2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">149</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> <span class="token operator">-</span><span class="token number">126</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">149</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">127</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">;</span>         <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0xff</span> <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h1><p>&emsp;&emsp;以上就是CSAPP DataLab的全部内容了，做完这个实验也算是对之前一段时间学习的一个巩固和练习吧，对于逻辑门运算和浮点运算也有了更多的了解。</p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
          <category> Lab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/10/08/hello-world/"/>
      <url>/2023/10/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
